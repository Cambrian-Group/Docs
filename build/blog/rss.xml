<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>LMAX Docs Blog</title>
        <link>https://docs.lmax.pro/blog</link>
        <description>LMAX Docs Blog</description>
        <lastBuildDate>Mon, 21 Feb 2022 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <item>
            <title><![CDATA[Introduction to Celo Progressive DAppstarter]]></title>
            <link>https://docs.lmax.pro/blog/2022/02/21/introduction-to-celo-progressive-dappstarter</link>
            <guid>/2022/02/21/introduction-to-celo-progressive-dappstarter</guid>
            <pubDate>Mon, 21 Feb 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[Quickly develop full-stack progressive web applications on Celo.]]></description>
            <content:encoded><![CDATA[<p>Quickly develop full-stack progressive web applications on the Celo blockchain.</p><hr/><h2>Getting started</h2><p>Welcome to the <a href="https://celo-progressive-dapp-starter.netlify.app/">Celo Progressive Dappstarter</a>—a starter pack to get you up and running fast with Celo DApp development. The goal of this post is to get you up and running <a href="https://github.com/celo-org/celo-progressive-dapp-starter">Celo Progressive Dapp starter</a> in about 15 minutes or less. From there you can quickly build, iterate, and deploy new DApps on the Celo blockchain.</p><p><strong>Here&#x27;s a quick look at what you&#x27;ll build</strong></p><p><img src="/img/doc-images/introduction-to-celo-progressive-dappstarter/1.png" alt="dappstarter"/></p><h2>Watch the video</h2><p>Check out this video for an overview of the topics covered in this post.</p><div videoId="MQg2sta0lr8"></div><p>:::info README</p><p>View the project <a href="https://github.com/celo-org/celo-progressive-dapp-starter">README</a> for a quick summary of steps in this video.</p><p>:::</p><h2>Prerequisites</h2><p>To start building, you’ll need a basic understanding of web development, Node (v12), yarn, and Git.</p><ul><li>Node (v12), <a href="https://github.com/nvm-sh/nvm">NVM</a></li><li>Yarn</li><li>Git</li></ul><h2>Project stack</h2><p>The Celo Progressive Dappstarter uses the <a href="https://nextjs.org/">Next.js</a> React framework with <a href="https://mui.com/">Material UI</a>, and <a href="https://www.npmjs.com/package/@celo-tools/use-contractkit">use-contractkit</a> Celo library to get you started with building a responsive, web3 DApp quickly. The goal is to get you started quickly for ha reference and extend it with any web3 packages you are familiar with.</p><h2>Set up your project repo</h2><p>Navigate to the <a href="https://github.com/celo-org/celo-progressive-dapp-starter">project repo</a> and select <strong>Use this template</strong></p><p><img src="/img/doc-images/introduction-to-celo-progressive-dappstarter/2.png" alt="dappstarter"/></p><p>Add a repository <strong>name</strong>, <strong>description </strong>and click <strong>Create repository from template.</strong></p><p><img src="/img/doc-images/introduction-to-celo-progressive-dappstarter/3.png" alt="dappstarter"/></p><p>:::info Include all branches</p><p>This template will soon include additional branches with new features. If you would like to include these branches in your repository, select <strong>Include all branches</strong>.</p><p>:::</p><h2>Create a local project</h2><p>From your new GitHub repository, select code, and copy the GitHub URL for your project.</p><p><img src="/img/doc-images/introduction-to-celo-progressive-dappstarter/4.png" alt="dappstarter"/></p><p>Open your terminal, navigate to your project directory, and <code>git clone</code> your project using the GitHub URL.</p><pre><code>git clone https://github.com/path-to-your-project-repo
</code></pre><p><img src="/img/doc-images/introduction-to-celo-progressive-dappstarter/5.png" alt="dappstarter"/></p><p>Navigate into your Celo project and run <code>nvm use</code> to switch to a Celo compatible Node version. Celo is compatible with Node v12 as specified in <code>.nvmrc</code> of the project folder.</p><pre><code>cd celo-progressive-dapp-starter
nvm use
</code></pre><p><img src="/img/doc-images/introduction-to-celo-progressive-dappstarter/6.png" alt="dappstarter"/></p><h2>Setup your testnet account</h2><p>Create a new account and print the account number and private key using <a href="https://hardhat.org/">hardhat</a> <code>create-account</code>.</p><pre><code>npx hardhat create-account
</code></pre><p><img src="/img/doc-images/introduction-to-celo-progressive-dappstarter/7.png" alt="dappstarter"/></p><p>Copy the testnet account address, paste it into the <a href="https://celo.org/developers/faucet">Celo Testnet Faucet</a> and select <strong>Get Started</strong> to transfer funds into your testnet account.</p><p><img src="/img/doc-images/introduction-to-celo-progressive-dappstarter/8.png" alt="dappstarter"/></p><p>Import a new MetaMask account using your private key to view your newly funded Testnet Account.</p><p><img src="/img/doc-images/introduction-to-celo-progressive-dappstarter/9.png" alt="dappstarter"/></p><p>:::info MetaMask Setup</p><p>Learn more about setting up your Alfajores Testnet with MetaMask <a href="https://docs.celo.org/getting-started/wallets/using-metamask-with-celo/manual-setup#adding-a-celo-network-to-metamask">here</a></p><p>:::</p><h2>Deploy smart contracts</h2><p>Change into the hardhat directory and install the project dependencies.</p><pre><code>cd packages/hardhat
yarn install
</code></pre><p><img src="/img/doc-images/introduction-to-celo-progressive-dappstarter/10.png" alt="dappstarter"/></p><p>Open your projects <code>.env</code> file and replace <code>PRIVATE_KEY</code> with the account <strong>private key</strong> from your terminal.</p><p><img src="/img/doc-images/introduction-to-celo-progressive-dappstarter/11.png" alt="dappstarter"/></p><p>Return to your terminal and run <code>yarn deploy</code> to deploy your smart contracts.</p><p>:::info Redeploy contracts</p><p>You can run <strong>yarn deploy --reset</strong> to force re-deploy your contracts to any chain.</p><p>:::</p><p><img src="/img/doc-images/introduction-to-celo-progressive-dappstarter/12.png" alt="dappstarter"/></p><h2>Start the front-end</h2><p>Navigate into the react-app directory and run <code>yarn install</code> to install the project front-end dependencies.</p><pre><code>cd packages/react-app
yarn install
yarn dev
</code></pre><p><img src="/img/doc-images/introduction-to-celo-progressive-dappstarter/13.png" alt="dappstarter"/></p><p>Run <code>yarn dev</code> to start your development environment.</p><pre><code>yarn dev
</code></pre><p><img src="/img/doc-images/introduction-to-celo-progressive-dappstarter/14.png" alt="dappstarter"/></p><p>Open <a href="http://localhost:3000/">localhost:3000 </a>to view your project.</p><p><img src="/img/doc-images/introduction-to-celo-progressive-dappstarter/15.png" alt="dappstarter"/></p><h2>Explore your dApp</h2><p>Enter a value in the <strong>write contract </strong>function and confirm the transaction to store a value.</p><p><img src="/img/doc-images/introduction-to-celo-progressive-dappstarter/16.png" alt="dappstarter"/></p><p>Once the transaction has been complete (approximately 5 seconds) you may view the transaction using the alert that appears with a link to the <a href="https://alfajores-blockscout.celo-testnet.org/">Celo Alfajores Block Explorer</a>.</p><p><img src="/img/doc-images/introduction-to-celo-progressive-dappstarter/17.png" alt="dappstarter"/></p><p>You should now be able to view the updated storage value using the <strong>Read Storage Contract </strong>function.</p><p><img src="/img/doc-images/introduction-to-celo-progressive-dappstarter/18.png" alt="dappstarter"/></p><p>View the <strong>Greeter Contract </strong>using the tabs to interact with a similar contract that allows you to read and write string values rather than numbers.</p><p><img src="/img/doc-images/introduction-to-celo-progressive-dappstarter/19.png" alt="dappstarter"/></p><h2>Customize your dApp</h2><p>Smart contracts for this project are in the <strong>packages/hardhat/contracts </strong>folder.</p><p><img src="/img/doc-images/introduction-to-celo-progressive-dappstarter/20.png" alt="dappstarter"/></p><p>The deploy scripts for each smart contract are found in<strong> packages/hardhat/deploy/00-deploy.js</strong>.</p><p><img src="/img/doc-images/introduction-to-celo-progressive-dappstarter/21.png" alt="dappstarter"/></p><p>The front-end code for each smart contract interface are found in <strong>packages/react-app/components </strong>and are named as components that should be similar to the name of the smart contract.</p><p><img src="/img/doc-images/introduction-to-celo-progressive-dappstarter/22.png" alt="dappstarter"/></p><p>:::info Redeploy contracts</p><p>You can run <strong>yarn deploy --reset</strong> to force re-deploy your contracts to any chain.</p><p>:::</p><h2>View on Mobile</h2><p>Serve your React app to your mobile device for testing via a tunnel. Next.js defaults to serving your app on <code>port 3000</code>.</p><pre><code>npx localtunnel --port 3000
</code></pre><p>:::info Local Tunnel</p><p>Read more about localtunnel <a href="https://www.npmjs.com/package/localtunnel">here</a>.</p><p>:::</p><p><img src="/img/doc-images/introduction-to-celo-progressive-dappstarter/23.png" alt="dappstarter"/></p><p>Your Celo dApp is now available on your mobile device at the URL provided in your terminal.</p><h2>Contribute to the project</h2><p>We welcome contributions to this repository! If you decide to try this out and find something confusing, consider opening a pull request to make things more clear for the next developer. If you improve the user interface or create new components that you think might be useful for other developers, consider opening a PR.</p><p>We will happily compensate you for your contributions. Anywhere between 5 and 50 cUSD (or more) will be awarded to contributors depending on the scope of the work as determined by the Celo Foundation Developer Relations team.</p><p>:::info Get Support</p><p>Join the <a href="https://chat.celo.org/">Celo Discord server</a> or reach out on the dedicated repo channel
<a href="https://discord.com/channels/600834479145353243/941003424298856448">here</a>.</p><p>:::</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Celo Valora + WalletConnect v1]]></title>
            <link>https://docs.lmax.pro/blog/2022/01/08/valora-wc-v1</link>
            <guid>/2022/01/08/valora-wc-v1</guid>
            <pubDate>Sat, 08 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[How to use Wallet Connect version 1 in a DApp to connect to Valora.]]></description>
            <content:encoded><![CDATA[<p>How to use <a href="https://docs.walletconnect.com/1.0/">WalletConnect version 1</a> in a DApp to connect to <a href="https://valoraapp.com/">Valora</a>.</p><h2>Getting Started</h2><p>In this example, we will demonstrate how to add WalletConnect to a simple React app.</p><p>This is a simple DApp that focuses on demonstrating how to connect WalletConnect to Valora, but also shows how to set up <a href="/developer-guide/contractkit">ContractKit</a> and make a simple cUSD transfer. You can view the DApp code <a href="https://github.com/critesjosh/valora-wallet-connect-v1">here</a>.</p><h2>Add Packages</h2><p>Add the packages that you need to your project.</p><ul><li><a href="https://www.npmjs.com/package/@walletconnect/web3-provider">@walletconnect/web3-provider</a></li><li><a href="https://www.npmjs.com/package/@celo/contractkit">Contractkit</a></li><li><a href="https://www.npmjs.com/package/web3">Web3</a></li></ul><pre><code class="language-shell">yarn add @wallet-connect/web3-provider web3 @celo/contractkit
</code></pre><p>Import the packages to your project code.</p><pre><code class="language-js">import WalletConnectProvider from &quot;@walletconnect/web3-provider&quot;;
import Web3 from &quot;web3&quot;;
import { newKitFromWeb3 } from &quot;@celo/contractkit&quot;;
</code></pre><h2>Connect</h2><p>If the DApp does not detect a <a href="https://docs.walletconnect.com/1.0/quick-start/dapps/web3-provider">wallet connect provider</a>, the user will be presented with a button to initiate a wallet connection.</p><p>If the DApp is being accessed on a computer or device other than the mobile device with the wallet, the user can connect to the mobile wallet by scanning the presented QR code. If the DApp is being accessed on the same device as the wallet, the connection will be made via the appropriate linking mechanism (iOS and Android are different). You can read more about that <a href="https://docs.walletconnect.com/1.0/mobile-linking#wallet-support">here</a>.</p><p>When a provider is detected, the DApp will show a button to send some cUSD.</p><p><img src="/img/doc-images/valora-wc-v1/connect-dapp.png" alt="connect dapp"/></p><p>The connect function sets up the WalletConnect Provider and initializes ContractKit with the provider and user account. It also sets up a listener that will log when the user changes accounts. The DApp then saves the provider and initialized Contractkit in the <a href="https://reactjs.org/docs/faq-state.html">React component state</a>.</p><pre><code class="language-js">connect = async () =&gt; {
  const provider = new WalletConnectProvider({
    rpc: {
      44787: &quot;https://alfajores-forno.celo-testnet.org&quot;,
      42220: &quot;https://forno.celo.org&quot;,
    },
  });

  await provider.enable();
  const web3 = new Web3(provider);
  let kit = newKitFromWeb3(web3);

  kit.defaultAccount = provider.accounts[0];

  provider.on(&quot;accountsChanged&quot;, (accounts) =&gt; {
    console.log(accounts);
  });

  this.setState({ provider, kit });
};
</code></pre><p><strong>DApp:</strong></p><p><img src="/img/doc-images/valora-wc-v1/qr-code.png" alt="qr code"/></p><p><strong>Valora:</strong></p><div path="/img/doc-images/valora-wc-v1/connect-valora.jpg" alt="connect valora" width="200"></div><p>When the provider has been set and the DApp is connected to Valora, the UI will update the button and display the user account address below.</p><p><img src="/img/doc-images/valora-wc-v1/send-cusd.png" alt="send cusd"/></p><h2>Send cUSD</h2><p>Clicking the new button will prompt the user to send 0.001 cUSD to a hard-coded address. The user will have to click Allow to send the transaction. Once the transaction is confirmed, the transaction receipt will be printed in the DApp browser console.</p><p>You can code the transaction approval request with just a few lines, demonstrated in the <code>sendcUSD</code> function.</p><ul><li>Get the saved instance of ContractKit from <code>this.state.kit</code></li><li>Get the stabletoken (cUSD) contract</li><li>Call <code>transfer</code> and <code>send</code> with the recipient and amount</li></ul><pre><code class="language-js">sendcUSD = async () =&gt; {
  let kit = this.state.kit;

  let amount = kit.web3.utils.toWei(&quot;0.001&quot;, &quot;ether&quot;);

  const stabletoken = await kit.contracts.getStableToken();
  const tx = await stabletoken.transfer(this.state.someAddress, amount).send();
  const receipt = await tx.waitReceipt();

  console.log(receipt);
};
</code></pre><div path="/img/doc-images/valora-wc-v1/valora-send.jpg" alt="approve valora" width="200"></div><p>The receipt will be logged once the user approves the transaction and it is confirmed on the network.</p><h2>Pay Fees in Stable currencies</h2><p>Specifying the <code>feeCurrency</code> field in the transaction will allow users to pay transaction fees in that currency. Here&#x27;s how you can have users pay transaction fees in cUSD, for example:</p><pre><code class="language-js">const stabletoken = await kit.contracts.getStableToken();
let tx = await stabletoken
  .transfer(this.state.someAddress, amount)
  .send({ feeCurrency: stabletoken.address });
</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Use onchain randomness]]></title>
            <link>https://docs.lmax.pro/blog/developer-guide/start/randomness</link>
            <guid>/developer-guide/start/randomness</guid>
            <pubDate>Fri, 07 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[How to use onchain randomness in your smart contracts.]]></description>
            <content:encoded><![CDATA[<p>Onchain randomness is used for selecting validators to perform phone number verification. Read more about how onchain randomness is produced at the provided page.</p><div url="/celo-codebase/protocol/identity/randomness" pageName="Randomness"></div><p>This randomness can be used by any smart contracts deployed to a Celo network.</p><pre><code class="language-solidity">import &quot;celo-monorepo/packages/protocol/identity/interfaces/IRandom.sol&quot;;
import &quot;celo-monorepo/packages/protocol/common/interfaces/IRegistry.sol&quot;;

contract Example {
    function test() external view returns (bytes32 randomness) {
        randomness = IRandom(
            IRegistry(0x000000000000000000000000000000000000ce10)
                .getAddressFor(keccak256(abi.encodePacked(&quot;Random&quot;)))
        ).random();
    }
}
</code></pre><p>Alternatively, through inheritance of <code>UsingRegistry</code>.</p><pre><code class="language-solidity">import &quot;celo-monorepo/packages/protocol/common/UsingRegistryV2.sol&quot;;

contract Example is UsingRegistryV2 {
    function test() external view returns (bytes32 randomness) {
        randomness = getRandom().random();
    }
}
</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[React based DApp]]></title>
            <link>https://docs.lmax.pro/blog/developer-guide/start/web-dapp</link>
            <guid>/developer-guide/start/web-dapp</guid>
            <pubDate>Thu, 06 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[The basics of developing a decentralised application (DApp) on Celo.]]></description>
            <content:encoded><![CDATA[<p>The basics of developing a decentralised application (DApp) on Celo.</p><h2>Getting Started</h2><p>This example will develop using one of the core Celo contracts, <a href="https://github.com/celo-org/celo-monorepo/blob/master/packages/protocol/contracts/governance/Governance.sol">Governance.sol</a>, and allowing users of our DApp to vote on active </p><h2>Foreword</h2><p>This guide requires an understanding of a few popular web technologies. Our application will be written in <a href="https://reactjs.org/">React</a>, utilising <a href="https://reactjs.org/docs/hooks-intro.html">hooks</a> for state management and built with <a href="https://nextjs.org/">Next.js</a>, a popular static site generation framework.</p><p>If you find this tutorial lacking in any way or want to dive into the code more thoroughly, checkout the <a href="https://github.com/alexbharley/celo-tools">Celo Tools</a> GitHub repository where much of this tutorial has been ported from.</p><h2>Getting started</h2><p>Step one of developing our application is scaffolding it out with <code>create-next-app</code> and adding TypeScript compilation so we can develop more confidently.</p><pre><code class="language-bash">yarn create next-app voting-dapp
cd voting-dapp
touch tsconfig.json
yarn add --dev typescript @types/react @types/node
</code></pre><p>Now running <code>yarn dev</code> should open up our new Next.js website on <code>localhost:3000</code>.</p><p>Next we&#x27;ll need to add a few Celo specific dependencies so we can work with our core contracts.</p><pre><code class="language-bash">yarn add @celo/contractkit @celo-tools/use-contractkit bignumber.js
</code></pre><p>Here&#x27;s what we&#x27;ll be using each of these packages for:</p><ul><li><a href="https://github.com/celo-org/celo-monorepo/tree/master/packages/sdk/contractkit">@celo/contractkit</a> is a lightweight wrapper around the <a href="https://web3js.readthedocs.io/">Web3</a> object you may already be familiar with. It contains typed interfaces for the core contracts (generated from the Contract ABIs) and helper functions to make common operations on Celo easier</li><li><a href="https://github.com/celo-tools/use-contractkit">@celo-tools/use-contractkit</a> is a community provided library to ease establishing the connection with a user&#x27;s wallet, whether that is a hardware, mobile, or web wallet. When developing with this library, your users can hold Celo via <a href="https://valoraapp.com">Valora</a>, a Ledger, Metamask and more</li><li><a href="https://github.com/MikeMcl/bignumber.js/">bignumber.js</a> is a library for expressing large numbers in JavaScript. When interacting with a blockchain we often need to handle arbitrary-precision decimal and non-decimal arithmetic.</li></ul><p>We&#x27;ll also need to add some Next.js config to work with these packages. Update next.config.js with the following:</p><pre><code class="language-javascript" metastring="title=&quot;next.config.js&quot;" title="&quot;next.config.js&quot;">module.exports = {
  webpack: (config) =&gt; {
    config.resolve.fallback = {
      ...config.resolve.fallback,
      fs: false,
      net: false,
      child_process: false,
      readline: false,
    };
    return config;
  },
};
</code></pre><p>We&#x27;ll need to restart the server for the config changes to take effect.</p><h2>Developing the application</h2><p>After all our boilerplate has been setup, we&#x27;re ready to start developing our application.</p><h3>Connecting to the user&#x27;s wallet</h3><p>When a user wants to interact with your DApp we need to somehow allow them to connect their wallet. Interaction with on chain smart contracts is impossible without this step.</p><p>Leveraging our previously added <a href="https://github.com/celo-tools/use-contractkit">@celo-tools/use-contractkit</a> library we can provide a button that prompts the user to connect their wallet.</p><p>Update pages/index.js with the following:</p><pre><code class="language-javascript" metastring="title=&quot;pages/index.js&quot;" title="&quot;pages/index.js&quot;">import React from &quot;react&quot;;
import { useContractKit } from &quot;@celo-tools/use-contractkit&quot;;
import { ContractKitProvider } from &quot;@celo-tools/use-contractkit&quot;;
import &quot;@celo-tools/use-contractkit/lib/styles.css&quot;;

function App() {
  const { address, connect } = useContractKit();

  return (
    &lt;main&gt;
      &lt;h1&gt;Celo Voting DApp&lt;/h1&gt;
      &lt;p&gt;{address}&lt;/p&gt;
      &lt;button onClick={connect}&gt;Click here to connect your wallet&lt;/button&gt;
    &lt;/main&gt;
  );
}

function WrappedApp() {
  return (
    &lt;ContractKitProvider
      dapp={{
        name: &quot;My awesome dApp&quot;,
        description: &quot;My awesome description&quot;,
        url: &quot;https://example.com&quot;,
      }}
    &gt;
      &lt;App /&gt;
    &lt;/ContractKitProvider&gt;
  );
}
export default WrappedApp;
</code></pre><p>Clicking this button will show the <code>use-contractkit</code> modal and allow the user to connect with their wallet of choice. Once the modal has been dismissed, the <code>address</code> property exposed by <code>use-contractkit</code> will be filled with the users primary account.</p><h3>Accessing contracts</h3><p>After that we&#x27;ve connected to the user&#x27;s wallet we can show interesting information based on their address. In the context of a governance voting DApp it may make sense to show past proposals they&#x27;ve voted on. If we were creating a simple banking interface, we could imagine wanting to show transfers into and out of the users account.</p><p>:::info</p><p>On the Celo blockchain, only queued and dequeued proposals are kept in the Governance state. That means to access old proposals we&#x27;d need to access an indexed history of the blockchain. This is out of scope for our tutorial however there&#x27;s many resources online you can find that will help you accessing indexed blockchain state.</p><p>For a comprehensive look at how to interpret this on chain state, take a look at the implementation for the <a href="https://github.com/celo-org/celo-monorepo/blob/master/packages/cli/src/commands/governance/list.ts">celocli governance:list</a> command.</p><p>For the purposes of this tutorial, we&#x27;ll only be looking at dequeued proposals, or proposals we can currently vote on.</p><p>:::</p><p>Here&#x27;s how it looks using a combination of the <code>useEffect</code> and <code>useCallback</code> hooks to request and display all dequeued proposals from the blockchain.</p><pre><code class="language-javascript" metastring="title=&quot;pages/index.js&quot;" title="&quot;pages/index.js&quot;">import React, { useCallback, useEffect, useState } from &quot;react&quot;;
import { useContractKit } from &quot;@celo-tools/use-contractkit&quot;;

function GovernanceApp() {
  const { address, connect, kit, getConnectedKit } = useContractKit();
  const [proposals, setProposals] = useState([]);

  const fetchProposals = useCallback(async () =&gt; {
    const governance = await kit.contracts.getGovernance();
    const dequeue = await governance.getDequeue();

    const fetchedProposals = await Promise.all(
      dequeue.map(async (id) =&gt; ({
        id,
        ...(await governance.getProposalRecord(id)),
      }))
    );
    setProposals(fetchedProposals);
  }, [kit]);

  useEffect(() =&gt; {
    fetchProposals();
  }, [fetchProposals]);

  return (
    &lt;div&gt;
      &lt;h1&gt;Celo Voting DApp&lt;/h1&gt;
      &lt;p&gt;{address}&lt;/p&gt;
      &lt;button onClick={connect}&gt;Click here to connect your wallet&lt;/button&gt;
      &lt;table&gt;
        &lt;thead&gt;
          &lt;tr&gt;
            &lt;th&gt;ID&lt;/th&gt;
            &lt;th&gt;Status&lt;/th&gt;
            &lt;th&gt;Description URL&lt;/th&gt;
          &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
          {proposals.map((proposal) =&gt; (
            &lt;tr&gt;
              &lt;td&gt;{proposal.id.toString()}&lt;/td&gt;
              &lt;td&gt;
                {proposal.passed
                  ? &quot;Passed&quot;
                  : proposal.approved
                  ? &quot;Approved&quot;
                  : &quot;Not approved&quot;}
              &lt;/td&gt;
              &lt;td&gt;
                &lt;a
                  href={proposal.metadata.descriptionURL}
                  target=&quot;_blank&quot;
                  style={{ color: &quot;blue&quot;, textDecoration: &quot;underline&quot; }}
                &gt;
                  Link
                &lt;/a&gt;
              &lt;/td&gt;
            &lt;/tr&gt;
          ))}
        &lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/div&gt;
  );
}
</code></pre><p>Be sure to add this new <code>GovernanceApp</code> component to your <code>WrappedApp</code> component.</p><pre><code class="language-js" metastring="title=&quot;pages/index.js&quot;" title="&quot;pages/index.js&quot;">function WrappedApp() {
  return (
    &lt;ContractKitProvider
      dapp={{
        name: &quot;My awesome dApp&quot;,
        description: &quot;My awesome description&quot;,
        url: &quot;https://example.com&quot;,
      }}
    &gt;
      &lt;GovernanceApp /&gt;
    &lt;/ContractKitProvider&gt;
  );
}
</code></pre><p>This works pretty well however it makes sense to additionally show whether the user has voted on any given dequeued governance proposal. To show that information, we can amend our <code>fetchProposals</code> function as follows</p><pre><code class="language-js" metastring="title=&quot;pages/index.js&quot;" title="&quot;pages/index.js&quot;">const fetchProposals = useCallback(async () =&gt; {
  if (!address) {
    return;
  }

  const governance = await kit.contracts.getGovernance();
  const dequeue = await governance.getDequeue();

  const fetchedProposals = await Promise.all(
    dequeue.map(async (id) =&gt; {
      const [record, voteRecord] = await Promise.all([
        governance.getProposalRecord(id),
        governance.getVoteRecord(address, id),
      ]);

      return {
        id,
        ...record,
        vote: voteRecord ? voteRecord.value : undefined,
      };
    })
  );
  setProposals(fetchedProposals);
}, [kit, address]);
</code></pre><p>Now we have access to whether the user voted on this proposal, we can render that information in our table.</p><pre><code class="language-js" metastring="title=&quot;pages/index.js&quot;" title="&quot;pages/index.js&quot;">return (
  &lt;table&gt;
    &lt;thead&gt;
      &lt;tr&gt;
        &lt;th&gt;ID&lt;/th&gt;
        &lt;th&gt;Status&lt;/th&gt;
        &lt;th&gt;Description URL&lt;/th&gt;
        &lt;th&gt;Voted&lt;/th&gt;
      &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
      {proposals.map((proposal) =&gt; (
        &lt;tr&gt;
          &lt;td&gt;{proposal.id.toString()}&lt;/td&gt;
          &lt;td&gt;
            {proposal.passed
              ? &quot;Passed&quot;
              : proposal.approved
              ? &quot;Approved&quot;
              : &quot;Not approved&quot;}
          &lt;/td&gt;
          &lt;td&gt;
            &lt;a
              style={{ color: &quot;blue&quot;, textDecoration: &quot;underline&quot; }}
              href={proposal.metadata.descriptionURL}
              target=&quot;_blank&quot;
            &gt;
              Link
            &lt;/a&gt;
          &lt;/td&gt;
          &lt;td&gt;{proposal.vote ?? &quot;No vote yet&quot;}&lt;/td&gt;
        &lt;/tr&gt;
      ))}
    &lt;/tbody&gt;
  &lt;/table&gt;
);
</code></pre><h3>Locking Celo (optional)</h3><p>A prerequisite  having locked Celo to vote with. We won&#x27;t cover the various flows for locking, unlocking and relocking Celo in this tutorial but you can check the implementation in <a href="https://github.com/alexbharley/celo-tools">Celo Tools</a> or take inspiration from the following script:</p><pre><code class="language-javascript">const lockValue = new BigNumber(res.flags.value);

const lockedGold = await this.kit.contracts.getLockedGold();
const pendingWithdrawalsValue =
  await lockedGold.getPendingWithdrawalsTotalValue(address);
const relockValue = BigNumber.minimum(pendingWithdrawalsValue, value);
const lockValue = value.minus(relockValue);

const txos = await lockedGold.relock(address, relockValue);
for (const txo of txos) {
  await kit.sendAndWaitForReceipt({ from: address });
}
</code></pre><p>All you need to take care of in your React application is handling user input to select the amount to lock and handling errors in case the user tries to lock more CELO than they hold.</p><p>It&#x27;s also possible that users of your DApp already have locked CELO, so you might not need to worry about the complexity of permitting that operation.</p><h3>Voting on a proposal</h3><p>To actually vote on a proposal we need to again interact with the <a href="https://github.com/celo-org/celo-monorepo/blob/master/packages/protocol/contracts/governance/Governance.sol">Governance.sol</a> smart contract. Our logic for handling a vote looks as follows:</p><pre><code class="language-typescript" metastring="title=&quot;pages/index.js&quot;" title="&quot;pages/index.js&quot;">const vote = useCallback(
  async (id: string, value: VoteValue) =&gt; {
    const kit = await getConnectedKit();
    const governance = await kit.contracts.getGovernance();
    await (await governance.vote(id, value)).sendAndWaitForReceipt();
    fetchProposals();
  },
  [kit, fetchProposals]
);
</code></pre><p>How you handle calling that function is up to you. With <a href="https://github.com/alexbharley/celo-tools">Celo Tools</a> we opted for simple upwards and downwards facing arrows to handle voting on proposals, however the data can be rendered however you&#x27;d prefer.</p><p>Here&#x27;s a simple example showing buttons for <code>Yes</code> or <code>No</code> votes when no vote has been cast.</p><pre><code class="language-javascript" metastring="title=&quot;pages/index.js&quot;" title="&quot;pages/index.js&quot;">import { VoteValue } from &quot;@celo/contractkit/lib/wrappers/Governance&quot;;

return (
  &lt;tr&gt;
    &lt;td&gt;{proposal.id.toString()}&lt;/td&gt;
    &lt;td&gt;
      {proposal.passed
        ? &quot;Passed&quot;
        : proposal.approved
        ? &quot;Approved&quot;
        : &quot;Not approved&quot;}
    &lt;/td&gt;
    &lt;td&gt;
      &lt;a href={proposal.descriptionURL} target=&quot;_blank&quot;&gt;
        Description link
      &lt;/a&gt;
    &lt;/td&gt;
    &lt;td&gt;
      {proposal.vote ? (
        &lt;span&gt;{proposal.vote}&lt;/span&gt;
      ) : (
        &lt;div&gt;
          &lt;button onClick={() =&gt; vote(proposal.id, VoteValue.Yes)}&gt;Yes&lt;/button&gt;
          &lt;button onClick={() =&gt; vote(proposal.id, VoteValue.No)}&gt;No&lt;/button&gt;
        &lt;/div&gt;
      )}
    &lt;/td&gt;
  &lt;/tr&gt;
);
</code></pre><h2>Best practices</h2><p>We&#x27;ve compiled a short list on best practices to follow when developing DApps. Following these will improve the end user experience and keep them more engaged with the Celo ecosystem. If you have any questions around these, feel free to <a href="https://chat.celo.org">reach out on Discord</a>, we&#x27;re always there and happy to chat.</p><h3>Last used address</h3><p><a href="https://github.com/celo-tools/use-contractkit">@celo-tools/use-contractkit</a> will remember the address a user last logged in with (via <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage">browser LocalStorage</a>). Use this to your advantage and allow your DApp to display the same data whether or not the user has connected their wallet. A good test is to refresh your DApp after connecting and see if anything changes. At the very most, buttons for interaction could be disabled, however it&#x27;s preferable to prompt to connect the wallet on button click.</p><p>Keeping the UI consistent by using the last connected address is a quick win we can have with DApps that make the experience using them closer to Web2, an experience more users will be familiar with.</p><h3>Loading states</h3><p>Loading times are often the give away that an application is a Web3 DApp. Be liberal with loading screens and prioritise making animations smooth.</p><p>Nothing is worse than a perpetually hanging screen that takes multiple seconds to become interactive. By showing a spinner it communicates to the user that things are happening, however slow they may be.</p><p>This is often offset by the ability to index a blockchain and provide the data in a more accessible format (maybe a SQL database or behind a GraphQL API). As mentioned earlier we haven&#x27;t covered that in this tutorial, however there&#x27;s a lot of content on the web around DApp optimisation through prior state indexing.</p><h3>Prerender what you can</h3><p>With modern static site generators we have amazing leverage over what gets computed server side and what the browser has to request and compute before rendering. If you&#x27;re unable to index the blockchain before a client requests access to a page, consider loading the relevant data server side with a cache invalidated every hour or so.</p><p>Next.js <a href="https://nextjs.org/docs/basic-features/data-fetching#getstaticprops-static-generation">getStaticProps</a> comes to mind here as a great way to offload heavy computation to the server.</p><h3>Showing numbers in wei vs. Celo vs. local currency</h3><p>Take this advice with a grain of salt as it really depends on how familiar with cryptocurrencies and blockchain your users are. At some point in most DApp users are going to need to deal with large numbers. It&#x27;s up to you whether you display these in wei (1e18) CELO or converted to a currency the user prefers (BTC, USD or EUR for example).</p><p>The sweeping generalisation would be to allow entering values in CELO or their preferred currency and never expose the raw wei amounts to end users.</p><h2>Wrapping up</h2><p>Hopefully you have a better grasp on developing DApps against the Celo core contracts now. In this tutorial we covered:</p><ul><li>Connecting to user wallets (<a href="https://github.com/celo-tools/use-contractkit">use-contractkit</a>)</li><li>Fetching on-chain data</li><li>Calling simple functions on the core contracts</li><li>A brief word on best practices with regard to DApp development.</li></ul><p>This is not a comprehensive tutorial for Celo&#x27;s features and capabilities, keep exploring the docs to learn more and please <a href="https://chat.celo.org">connect with us on Discord</a> if you need any help (or just want to chat)!</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Deploy an NFT to Celo]]></title>
            <link>https://docs.lmax.pro/blog/2022/01/05/no-code-erc721</link>
            <guid>/2022/01/05/no-code-erc721</guid>
            <pubDate>Wed, 05 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[How to deploy ERC721 tokens (NFTs) on the Celo network using autogenerated code.]]></description>
            <content:encoded><![CDATA[<p>How to deploy ERC721 tokens (NFTs) on the Celo network using autogenerated code.</p><h2>Getting Started</h2><p>In this example, we will be using IPFS for off-chain storage, but you can use whatever off-chain storage mechanism you want.</p><h2>Set up your wallet</h2><ol><li>Install <a href="https://metamask.io/">Metamask</a>.</li><li><a href="/getting-started/wallets/using-metamask-with-celo/manual-setup#adding-a-celo-network-to-metamask">Add the Celo network</a> to Metamask. We suggest adding the Alfajores testnet to Metamask as well, so you can test contract deployments before deploying to mainnet.</li><li>Add a small amount of CELO to your Metamask account. In this example, we will deploy to the Alfajores testnet, so we need Alfajores CELO, which you can get from the faucet <a href="https://celo.org/developers/faucet">here</a>.</li></ol><h2>Prepare the NFT metadata</h2><ol start="4"><li>Go to <a href="https://app.pinata.cloud/">https://app.pinata.cloud/</a> and sign up for an account if you don’t have one already. Pinata is a service that allows you to easily upload files to <a href="https://ipfs.io/">IPFS</a>.</li><li>Upload your NFT images to IPFS. Because storing data on a blockchain can be expensive, NFTs often reference off-chain data. In this example, We are creating a set of NFTs that reference pictures of trees. We uploaded all of the images of trees to IPFS individually. The names of the images correspond to the token ID. This isn’t necessary, we just did it for convenience. Notice that each image has a corresponding CID hash, this is the unique identifier for that file or folder. <img src="https://github.com/critesjosh/images/blob/main/token_deploy_tutorials/pinata%20upload%20image%20list.png?raw=true" alt="pinata upload image list.png"/></li><li>Once all of your images have been uploaded, you will need to prepare the token metadata in a new folder.<ol><li>We created a folder called “prosper factory metadata”. You can view the contents of the folder <a href="https://gateway.pinata.cloud/ipfs/QmdmA3gwGukA8QDPH7Ypq1WAoVfX82nx7SaXFvh1T7UmvZ">here</a>. The folder contains 14 files, numbered 0-13. <strong>The names of these files are important.</strong> These file names correspond to the token ID of each NFT that will be created by the contract. Make sure that there are no extensions (.txt, .json, .jpeg, .png) on your files. <img src="https://github.com/critesjosh/images/blob/main/token_deploy_tutorials/ipfs%20folder%20contents.png?raw=true" alt="ipfs folder contents.png"/></li><li>Click on one of the files. The files contain the NFT metadata. In this simple example, the metadata only contains a reference to the unique tree image. You can view the image in a browser that supports IPFS (we are using Brave) here. Each file should have a unique image reference. <img src="https://github.com/critesjosh/images/blob/main/token_deploy_tutorials/ipfs%20image%20metadata.png?raw=true" alt="ipfs image metadata.png"/> You will need to create a similarly structured folder containing metadata for all of the NFTs that you want to create.</li></ol></li><li>Upload the folder containing all of the token metadata to IPFS. This will make your NFT data publicly available. We called ours “prosper factory metadata”. Note the CID of this folder. We will need it shortly. <img src="https://github.com/critesjosh/images/blob/main/token_deploy_tutorials/pinata%20prosper%20factory%20metadata%20folder.png?raw=true" alt="pinata prosper factory metadata folder.png"/></li></ol><h2>Design and Deploy the Smart Contracts</h2><ol start="8"><li>Go to <a href="https://docs.openzeppelin.com/contracts/4.x/wizard">https://docs.openzeppelin.com/contracts/4.x/wizard</a></li><li>Select ERC721 as your token choice.</li><li>Enter your token information.<ol><li>We are calling our token the ProsperityFactory, symbol PF.</li><li>We entered the IPFS CID of our token metadata folder (prosper factory metadata) in the “Base URI” field. Be sure to add a trailing “/” to the base URI, the token ID will be appended to the end of the base URI to get the IPFS metadata file. So the complete Base URI for our NFT contract is <code>ipfs://QmdmA3gwGukA8QDPH7Ypq1WAoVfX82nx7SaXFvh1T7UmvZ/</code>. Again, you can view the folder <a href="https://gateway.pinata.cloud/ipfs/QmdmA3gwGukA8QDPH7Ypq1WAoVfX82nx7SaXFvh1T7UmvZ">here</a>.</li><li>We made the token mintable and it will automatically increment the token IDs as the tokens are minted. The counter starts at 0 and adds 1 to each successive token. It is important that the file contents of the IPFS metadata folder are labeled accordingly (ie. 0-13) and correspond to the token IDs.</li><li>The contract is also marked Ownable, meaning that only the owner of the contract (which is initially set to the account that deploys the contract) can mint new NFTs. <img src="https://github.com/critesjosh/images/blob/main/token_deploy_tutorials/erc721%20filled%20settings.png?raw=true" alt="erc721 filled settings.png"/></li></ol></li><li>Click “Open in Remix”. Remix will pop open with your contract code already filled in.</li><li>Click the big blue button on the left side of Remix that says “Compile contract-xxxx.sol”. <img src="https://github.com/critesjosh/images/blob/main/token_deploy_tutorials/remix%20compile%20erc721.png?raw=true" alt="remix compile erc721.png"/></li><li>Once the contract is compiled, click the Ethereum logo on the left side of the window. A new sidebar will appear. <img src="https://github.com/critesjosh/images/blob/main/token_deploy_tutorials/remix%20deploy%20page%20erc721.png?raw=true" alt="remix deploy page erc721.png"/></li><li>In the “Environment” dropdown, select “Injected Web3”. This will connect Remix and Metamask. Make sure that Metamask is connected to the correct network. In this example, We are deploying to the Alfajores testnet, so we see a textbox below the dropdown that says <code>Custom (44787) network</code>. 44787 is the network id for Alfajores. <img src="https://github.com/critesjosh/images/blob/main/token_deploy_tutorials/select%20injected%20web3.png?raw=true" alt="select injected web3.png"/></li><li>Select the contract that you want to deploy. We titled the contract the ProsperityFactory. <img src="https://github.com/critesjosh/images/blob/main/token_deploy_tutorials/select%20erc721%20contract.png?raw=true" alt="select erc721 contract.png"/></li><li>Click Deploy. Metamask will pop up asking you to confirm the transaction. <img src="https://github.com/critesjosh/images/blob/main/token_deploy_tutorials/remix%20deploy%20721%20tx.png?raw=true" alt="remix deploy 721 tx.png"/></li><li>Once the contract is deployed, Remix will show a newly deployed contract on the bottom left corner of the window. Expand the ProsperityFactory dropdown to see all of the contract functions. You can see the deployed ProsperityFactory NFT contract <a href="https://alfajores-blockscout.celo-testnet.org/address/0xD8ea7beC4820dbC22aCf87EB0cCFE50203a45A6F/transactions">here</a>. <img src="https://github.com/critesjosh/images/blob/main/token_deploy_tutorials/remix%20721%20contract%20interface.png?raw=true" alt="remix 721 contract interface.png"/></li><li>Let’s mint the first NFT. To do that we will call the safeMint function. The safeMint function needs an account address as an input, so it knows who to mint the token to. I’ll just enter the first Metamask address and click the orange button. Metamask will pop up, confirm the transaction. When the transaction is confirmed, this will have minted the first NFT, with token ID 0. <img src="https://github.com/critesjosh/images/blob/main/token_deploy_tutorials/safeMint.png?raw=true" alt="safeMint.png"/></li><li>Check the token metadata. You can verify that the token was minted by calling the “tokenURI” function with the expected token ID. We call the contract with token ID 0 and it returns an IPFS reference. <img src="https://github.com/critesjosh/images/blob/main/token_deploy_tutorials/721%20read%20token%20uri.png?raw=true" alt="721 read token uri.png"/></li><li>Navigating to this IPFS reference will show the token metadata for that NFT. <img src="https://github.com/critesjosh/images/blob/main/token_deploy_tutorials/ipfs%20token%20metadata.png?raw=true" alt="ipfs token metadata.png"/></li><li>Going to that IPFS reference will show the image for the token.</li></ol><p>We went through the same process and minted all 14 NFTs from this contract.</p><p>That’s it! You now know how to create your own NFT contract with corresponding metadata!</p><p>Let me know what you end up building and reach out if you have any questions, <a href="https://twitter.com/critesjosh_">@critesjosh<!-- -->_</a> on Twitter or joshc#0001 on Discord. Join the Celo discord at <a href="https://chat.celo.org">https://chat.celo.org</a>.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Deploy & Mint a Token]]></title>
            <link>https://docs.lmax.pro/blog/2022/01/04/no-code-erc20</link>
            <guid>/2022/01/04/no-code-erc20</guid>
            <pubDate>Tue, 04 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[How to deploy an ERC20 token contract to Celo.]]></description>
            <content:encoded><![CDATA[<p>How to deploy a token contract that use the ERC20 token standard to Celo without writing code.</p><h2>Getting Started</h2><p>In this tutorial, we will go over how to deploy an ERC20 token contract. The process is very similar for deploying other tokens as well.</p><ol><li>Install <a href="https://metamask.io/">Metamask</a>.</li><li><a href="/getting-started/wallets/using-metamask-with-celo/manual-setup#adding-a-celo-network-to-metamask">Add the Celo network</a> to Metamask. We suggest adding the Alfajores testnet to Metamask as well, so you can test contract deployments before deploying to mainnet.</li><li>Add a small amount of CELO to your Metamask account. In this example, we will deploy to the Alfajores testnet, so we need Alfajores CELO, which you can get from the faucet <a href="https://celo.org/developers/faucet">here</a>.</li><li>Go to the <a href="https://docs.openzeppelin.com/contracts/4.x/wizard">Open Zeppelin Contracts Wizard</a>.</li><li>Select <code>ERC20</code> as the type of contract that you would like to deploy.</li></ol><p><img src="https://github.com/critesjosh/images/blob/main/token_deploy_tutorials/erc20%20empty%20settings.png?raw=true" alt="erc20 empty settings.png"/></p><ol start="6"><li>Name your token. We are calling our token “ProsperityToken” in this example.</li><li>Select the features for your token. We are making ProsperityToken mintable, burnable and enabling snapshots, so the token may be used for governance. We are also making the contract Ownable, so the deployer of the contract can mint new tokens and distribute them as desired. Ideally, the owner account will be a multi-signature contract, so no single person has control over this token contract.
If you want the block explorer to recognize your token then leave &quot;Upgradeability&quot; unchecked and do not select one of the two radio options below it. Selecting one of these options will prevent the <a href="https://explorer.celo.org/">Celo block explorer</a> from recognizing your deployed contract as a token. If you want upgradability and do not care about the block explorer, feel free to make your token contract upgradable.</li></ol><p><img src="https://github.com/critesjosh/images/blob/main/token_deploy_tutorials/erc20%20filled%20settings.png?raw=true" alt="erc20 filled settings.png"/></p><ol start="8"><li>Open your contract in Remix by clicking “Open in Remix”. Remix will pop open with the contract code already filled in.</li><li>Click the big blue button that says “Compile contract-xxxxx.sol”. The contract should compile without error.</li></ol><p><img src="https://github.com/critesjosh/images/blob/main/token_deploy_tutorials/remix%20compile%20erc20.png?raw=true" alt="remix compile erc20.png"/></p><ol start="10"><li>Click the Ethereum logo in the left sidebar. This will bring up a new interface for deploying the contract.</li></ol><p><img src="https://github.com/critesjosh/images/blob/main/token_deploy_tutorials/remix%20deploy%20erc20.png?raw=true" alt="remix deploy erc20.png"/></p><ol start="11"><li>In the “Environment” section on the top left, select “Injected Web3”. This will connect Remix to Metamask. Now clicking the “deploy” button will deploy the contracts to whichever network Metamask is connected to. You should see a small textbox indicating that Remix is connected to a custom network. The Alfajores network id is 44787.</li></ol><p><img src="https://github.com/critesjosh/images/blob/main/token_deploy_tutorials/select%20injected%20web3.png?raw=true" alt="select injected web3.png"/></p><ol start="12"><li>In the Contract dropdown, select the contract that you want to deploy. In this example, it is called ProsperityToken.</li></ol><p><img src="https://github.com/critesjosh/images/blob/main/token_deploy_tutorials/select%20prosperitytoken%20erc20%20contract.png?raw=true" alt="select prosperitytoken erc20 contract.png"/></p><ol start="13"><li>Click Deploy. Metamask should pop open.</li></ol><p><img src="https://github.com/critesjosh/images/blob/main/token_deploy_tutorials/deploy%20prosperity%20token%20erc20.png?raw=true" alt="deploy prosperity token erc20.png"/></p><ol start="14"><li>Click Confirm. Once the transaction confirms (less than 5 seconds), a contract interface will appear in the bottom left, and transaction details will appear in the console at the bottom.</li></ol><p><img src="https://github.com/critesjosh/images/blob/main/token_deploy_tutorials/deployed%20prosperity%20token.png?raw=true" alt="deployed prosperity token.png"/></p><p>That’s it! We now have ProsperityToken deployed on Alfajores with the Metamask account as the contract owner.</p><p>You can see the contract information on the <a href="https://alfajores-blockscout.celo-testnet.org/">Alfajores block explorer</a>. Copy and paste the contract address or deployment transaction hash from the console output and paste it into the block explorer search bar or look up the deployment transaction info in the Metamask activity.</p><h2>Deploying your token on the Mainnet</h2><p>When you&#x27;re ready to deploy your token to the Celo Mainnet make sure to change the network of your connected wallet from Alfajores to the Celo Mainnet. Once you have done this you can simply redeploy the contract (you will not need to recompile it).</p><p>Note: When deploying to the Mainnet you will need to use real Celo to pay the gas fee (as opposed to using the faucet on the testnet). As of December 2021 this cost is less than $0.01 US. You can learn how to <a href="https://celo.org/buy">get Celo here</a>.</p><p>You can read about how to add your new token to the Celo Wallet <a href="/blog/add-token-celo-wallet">here</a>.</p><h2>Verify</h2><p>If you are unable to view your token on the block explorer, you may need to Verify it first. If you are able to see your token, you may skip this section.</p><p>Verifying your contract with Remix is straight-forward and allows anyone to read and interact with the contract on the block explorer. You can read more about verifying a contract with Remix on <a href="/developer-resources/deploy-remix#verify-the-smart-contract">this page</a>.</p><p>You can find my example contract <a href="https://alfajores-blockscout.celo-testnet.org/address/0x97d550A2540F902F4501e21A6c09f12B69173261/transactions">here</a>.</p><p>Let me know what you end up building and reach out if you have any questions, <a href="https://twitter.com/critesjosh_">@critesjosh<!-- -->_</a> on Twitter or joshc#0001 on Discord. Join the Celo discord at <a href="https://chat.celo.org">https://chat.celo.org</a>.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Deploy and Interact with Contracts (Remotely)]]></title>
            <link>https://docs.lmax.pro/blog/developer-guide/start/hello-contract-remote-node</link>
            <guid>/developer-guide/start/hello-contract-remote-node</guid>
            <pubDate>Mon, 03 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[How to deploy and interact your own smart contracts using a remote node.]]></description>
            <content:encoded><![CDATA[<p>How to deploy and interact your own smart contracts using a remote node.</p><p>:::tip</p><p>As Celo is fully EVM compatible, we inherit the rich developer ecosystem and tooling of the Ethereum community. You will be deploying a typical hello world smart contract onto the Alfajores testnet with the common Ethereum tool, Truffle.</p><p>:::</p><p>:::note</p><p>This page is similar to the Hello Contracts page, but this one will connect to a remote node (Forno) and do key management in the Truffle project.</p><p>:::</p><h2>Setup</h2><p>This guide assumes that you have a basic Node/<a href="https://www.npmjs.com/get-npm">NPM</a> setup.</p><p>:::info</p><p><a href="https://www.trufflesuite.com/docs/truffle/overview">Learn more about the Truffle development framework here.</a></p><p>:::</p><p>As you may know, Truffle is built for Ethereum developers. Because Celo has a similar network architecture and runs the Ethereum Virtual Machine, Celo developers are able to leverage many Ethereum developer tools. But it is important to keep in mind the differences. If you haven&#x27;t already, please review the Celo overview.</p><div url="/overview" pageName="Celo Overview"></div><p><a href="https://github.com/critesjosh/hello_contract-truffle">Clone this Truffle project from GitHub to get started</a>.</p><pre><code>git clone https://github.com/critesjosh/hello_contract-truffle.git
</code></pre><p>This is a basic truffle project, with some additional files to help us with account management and deploying to a remote Celo test net node. Run <code>npm install</code> to install of the project dependencies.</p><h2>Hello World!</h2><p>Add a contract with the command</p><pre><code class="language-text">truffle create contract HelloWorld
</code></pre><p>We will not go into the details of how to write Solidity in this exercise, but you can learn more at the <a href="https://solidity.readthedocs.io/en/latest/">Solidity documentation page</a>.</p><p>The contract will just store a name for now:</p><pre><code class="language-solidity" metastring="title=&quot;contracts/HelloWorld.sol&quot;" title="&quot;contracts/HelloWorld.sol&quot;">
pragma solidity &gt;=0.5.0 &lt;0.8.0;

contract HelloWorld {
  string name = &#x27;Celo&#x27;;

  function getName() public view returns (string memory) {
    return name;
  }

  function setName(string calldata newName) external {
    name = newName;
  }
}
</code></pre><h2>Prepare Deployment</h2><h3>Compile the contract</h3><p>Before you deploy the contract, you need to compile the Solidity code into Ethereum bytecode. The following truffle command will look in the <code>./contracts</code> directory and compile any new or updated Solidity (<code>.sol</code>) contracts.</p><pre><code>truffle compile
</code></pre><p>After compiling the contract, you need to create a migration to deploy the contract. For that, create a file in the <code>./migrations/</code> folder named <code>2_deploy_helloworld.js</code>:</p><p>:::info</p><p><a href="https://www.trufflesuite.com/docs/truffle/getting-started/running-migrations">Learn more about Truffle migrations here.</a></p><p>:::</p><pre><code class="language-javascript" metastring="title=&quot;migrations/2_deploy_helloworld.js&quot;" title="&quot;migrations/2_deploy_helloworld.js&quot;">var HelloWorld = artifacts.require(&quot;HelloWorld&quot;);

module.exports = function (deployer) {
  deployer.deploy(HelloWorld);
};
</code></pre><p>:::info</p><p>You can <a href="https://www.trufflesuite.com/docs/truffle/reference/configuration">learn more about Truffle configuration options here.</a></p><p>:::</p><h2>Deploy to Alfajores <!-- -->(<!-- -->Remotely<!-- -->)</h2><p>When you deploy contracts to the Celo network with a remote node, you have to sign the contract deployment transaction locally before sending it to the remote node to be broadcast to the network. This presents some unique challenges when using Ethereum development tools <!-- -->(<!-- -->like Truffle<!-- -->)<!-- --> because Celo transaction objects are slightly different than Ethereum transaction objects.</p><p>When you are ready to deploy your contract to Alfajores, you&#x27;ll need a Celo client connected to the testnet. In this exercise you will connect to a remote node to read and write to the public testnet (Alfajores), but you could also run a testnet node locally to perform the same actions.</p><p>Here are the steps to go through to deploy the contract to the Alfajores testnet.</p><ol><li>Connect to Forno <!-- -->(<!-- -->a remote Celo node service provider<!-- -->)</li><li>Get personal account information <!-- -->(<!-- -->generate a private key if required, stored in <code>./.env</code>)</li><li>Get your personal account address and fund it via the <a href="https://celo.org/build/faucet">faucet</a></li><li>Get the compiled contract bytecode</li><li>Create and sign the contract deployment transaction</li><li>Send transaction to the network</li></ol><p>Make sure the dependencies are installed with:</p><pre><code class="language-text">yarn install
</code></pre><p>Run the createAccount.js script with:</p><pre><code class="language-text">node createAccount.js
</code></pre><pre><code class="language-javascript" metastring="title=&quot;createAccount.js&quot;" title="&quot;createAccount.js&quot;">const Web3 = require(&quot;web3&quot;);
const web3 = new Web3(&quot;http://localhost:8545&quot;);

console.log(web3.eth.accounts.create());
</code></pre><p>The provided code will print a private key / account pair in the terminal. Copy and paste the printed <code>priavteKey</code> into a <code>PRIVATE_KEY</code> variable in a file called <code>.env</code>, similar to what is shown in the <code>.envexample</code> file. The <code>address</code> that is printed with the private key is the account that we will fund with the faucet.</p><p>If you go to the <a href="https://celo.org/build/faucet">Alfajores Faucet Page</a>, you can faucet your account some CELO and see your balance increase.</p><h3>Deploy the contract</h3><h4>Truffle Deployment</h4><p>Before you can use truffle for the migration, you need to set up the proper configuration in <code>./truffle-config.js</code>. At the top of <code>./truffle-config.js</code>, set up the <code>kit</code> by connecting to the test network and adding the account you just funded.</p><pre><code class="language-javascript" metastring="title=&quot;truffle.config.js&quot;" title="&quot;truffle.config.js&quot;">const ContractKit = require(&quot;@celo/contractkit&quot;);
const Web3 = require(&quot;web3&quot;);
require(&quot;dotenv&quot;).config();

const web3 = new Web3(&quot;https://alfajores-forno.celo-testnet.org&quot;);
const kit = ContractKit.newKitFromWeb3(web3);

kit.connection.addAccount(process.env.PRIVATE_KEY);
</code></pre><p>Then, in the <code>networks</code> object, you can add the initialized <code>kit</code>provider to an <code>alfajores</code> property.</p><pre><code class="language-javascript" metastring="title=&quot;truffle.config.js&quot;" title="&quot;truffle.config.js&quot;">  networks: {
    test: {
      host: &quot;127.0.0.1&quot;,
      port: 7545,
      network_id: &quot;*&quot;
    },
    alfajores: {
      provider: kit.connection.web3.currentProvider, // CeloProvider
      network_id: 44787,                             // Alfajores network id
      gas: 4000000,            // You need to include the gas limit
    }
  }
</code></pre><p>:::info</p><p>Truffle doesn&#x27;t estimate the gas properly, so you need to specify a gas limit in <code>truffle.config.js</code>.</p><p>:::</p><p>Now, deploy the contracts to Alfajores with this command:</p><pre><code class="language-javascript">truffle migrate --network alfajores
</code></pre><h4>Custom Node.js Deployment</h4><p>In this section, you will deploy a contract using a simple Node.js script to show how you can do it without using Truffle.</p><p>You need to compile the <code>HelloWorld.sol</code> contract using <!-- -->(<!-- -->if it isn&#x27;t already<!-- -->)<!-- -->:</p><pre><code class="language-javascript">truffle compile
</code></pre><p>This command will generate a <code>HelloWorld.json</code> file in the <code>./build/contracts/</code> directory. <code>HelloWorld.json</code> contains a lot of data about the contract, compiler and low level details. Import this file into the deployment script <code>celo_deploy.js</code> with:</p><pre><code class="language-javascript">const HelloWorld = require(&quot;./build/contracts/HelloWorld.json&quot;);
</code></pre><p>You are finally ready to deploy the contract. Use the <code>kit</code>to create a custom transaction that includes the contract bytecode.</p><pre><code class="language-javascript" metastring="title=&quot;celo_deploy.js&quot;" title="&quot;celo_deploy.js&quot;">let tx = await kit.connection.sendTransaction({
  from: address,
  data: HelloWorld.bytecode, // from ./build/contracts/HelloWorld.json
});
</code></pre><p>:::info</p><p>To deploy a contract on Celo, use the <code>kit.connection.sendTransaction()</code> function with no <code>to:</code> field and the contract bytecode in the <code>data</code> field. The account that you are sending the transaction from must have enough CELO to pay the transaction fee, unless you specify another currency as the <code>feeCurrency</code>, then you need enough of that currency to pay the transaction fee.</p><p>:::</p><p>The entire deployment script is about 20 lines of code.</p><pre><code class="language-javascript" metastring="title=&quot;celo_deploy.js&quot;" title="&quot;celo_deploy.js&quot;">const Web3 = require(&quot;web3&quot;);
const ContractKit = require(&quot;@celo/contractkit&quot;);
const web3 = new Web3(&quot;https://alfajores-forno.celo-testnet.org&quot;);
const privateKeyToAddress =
  require(&quot;@celo/utils/lib/address&quot;).privateKeyToAddress;
const kit = ContractKit.newKitFromWeb3(web3);
require(&quot;dotenv&quot;).config();
const HelloWorld = require(&quot;./build/contracts/HelloWorld.json&quot;);

async function awaitWrapper() {
  kit.connection.addAccount(process.env.PRIVATE_KEY); // this account must have a CELO balance to pay transaction fees

  // This account must have a CELO balance to pay tx fees
  // get some testnet funds at https://celo.org/build/faucet
  const address = privateKeyToAddress(process.env.PRIVATE_KEY);
  console.log(address);

  let tx = await kit.connection.sendTransaction({
    from: address,
    data: HelloWorld.bytecode,
  });

  const receipt = await tx.waitReceipt();
  console.log(receipt);
}

awaitWrapper();
</code></pre><p>Congratulations! You have deployed your first contract onto Celo! You can verify your contract deployment on <a href="https://alfajores-blockscout.celo-testnet.org/">Blockscout</a>. You can get the transaction hash from the receipt and look it up on the block explorer.</p><h3>Interacting with Custom Contracts</h3><p>Now HelloWorld.sol is deployed onto the Alfajores testnet. How can you interact with the deployed contract using ContractKit? <code>helloWorld.js</code> includes some example code that shows how you can do this.</p><p>There are 3 functions defined in <code>helloWorld.js</code> that accomplish this.</p><p>The first function, <code>initContract()</code>, reads the deployed contract information from the Truffle artifact at <code>HelloWorld.json</code>. With this information, you can create a new web3.js Contract instance:</p><pre><code class="language-javascript" metastring="title=&quot;helloWorld.js&quot;" title="&quot;helloWorld.js&quot;">async function initContract() {
  // Check the Celo network ID
  const networkId = await web3.eth.net.getId();

  // Get the contract associated with the current network
  const deployedNetwork = HelloWorld.networks[networkId];

  // Create a new contract instance with the HelloWorld contract info
  let instance = new kit.web3.eth.Contract(
    HelloWorld.abi,
    deployedNetwork &amp;&amp; deployedNetwork.address
  );

  getName(instance);
  setName(instance, &quot;hello world!&quot;);
}
</code></pre><p>After creating the contract instance, the <code>initContract()</code> function calls <code>getName()</code> and <code>setName()</code>.</p><p>The <code>getName()</code> function will call, return and print the <code>getName()</code> function of the provided instance of the HelloWorld contract.</p><pre><code class="language-javascript" metastring="title=&quot;helloWorld.js&quot;" title="&quot;helloWorld.js&quot;">async function getName(instance) {
  let name = await instance.methods.getName().call();
  console.log(name);
}
</code></pre><p>The <code>setName()</code> function is a bit more involved. First, it gets the account key from the provided <code>./secret</code> file, just like in <code>celo_deploy.js</code>. Then it creates a <code>txObject</code> that encodes a smart contract transaction call to <code>setName()</code> with the provided <code>newName</code> to the provided instance of the HelloWorld contract. Then the function sends the encoded transaction object to the network, waits for a reciept and prints it to the console.</p><pre><code class="language-javascript" metastring="title=&quot;helloWorld.js&quot;" title="&quot;helloWorld.js&quot;">async function setName(instance, newName) {
  // Add your account to ContractKit to sign transactions
  // This account must have a CELO balance to pay tx fees, get some https://celo.org/build/faucet
  kit.connection.addAccount(process.env.PRIVATE_KEY);
  const address = privateKeyToAddress(process.env.PRIVATE_KEY);

  // Encode the transaction to HelloWorld.sol according to the ABI
  let txObject = await instance.methods.setName(newName);

  // Send the transaction
  let tx = await kit.sendTransactionObject(txObject, { from: address });

  let receipt = await tx.waitReceipt();
  console.log(receipt);
}
</code></pre><p>The above method shows a more detail about how to create custom deployment transactions and scripts than the previous method.</p><p>As you can see, all the goodies from Ethereum apply to Celo, so virtually all tutorials and other content should be easily translatable to Celo.</p><p>Check out <a href="https://celo.org/build">https://celo.org/build</a> for more resources!</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Deploy a Contract on Celo (local node)]]></title>
            <link>https://docs.lmax.pro/blog/developer-guide/start/hellocontracts</link>
            <guid>/developer-guide/start/hellocontracts</guid>
            <pubDate>Sun, 02 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[How to deploy your own smart contracts onto Celo from a local node.]]></description>
            <content:encoded><![CDATA[<p>How to deploy your own smart contracts onto a Celo local node.</p><p>:::tip</p><p>As Celo is fully EVM compliant, we inherit the rich developer ecosystem and tooling of the Ethereum community. We will be deploying a typical hello world smart contract onto the Alfajores testnet with typical Ethereum tools like Truffle and Ganache.</p><p>:::</p><h2>Setup</h2><p>This guide assumes that you have a basic Node/<a href="https://www.npmjs.com/get-npm">NPM</a> setup (Node.js v12.x). If so, you can install truffle with:</p><pre><code>npm install -g truffle
</code></pre><p>In your desired project folder, intiialize a new truffle project:</p><pre><code>truffle init
</code></pre><h2>Hello World!</h2><p>Let&#x27;s add a contract with</p><pre><code>truffle create contract HelloWorld
</code></pre><p>Our contract will just store a name for now:</p><pre><code class="language-solidity">pragma solidity &gt;=0.5.0 &lt;0.7.0;

contract HelloWorld {
  string name = &#x27;Celo&#x27;;

  function getName() public view returns (string memory) {
    return name;
  }

  function setName(string calldata newName) external {
    name = newName;
  }
}
</code></pre><h2>Deploy locally</h2><p>Let&#x27;s create a migration to deploy the contract. For that, we need to create a file in the <code>migrations</code> folder named <code>2_deploy_helloworld.js</code>:</p><pre><code class="language-javascript">var HelloWorld = artifacts.require(&quot;HelloWorld&quot;);

module.exports = function (deployer) {
  deployer.deploy(HelloWorld);
};
</code></pre><p>To be able to actually deploy it though, we need a blockchain. For local development and testing, you can use our fork of ganache:</p><pre><code>npm install -g @celo/ganache-cli
</code></pre><p>And then start ganache with:</p><pre><code>ganache-cli --port 7545
</code></pre><p>In your <code>truffle-config.js</code>, you&#x27;ll want to add your local test network under networks:</p><pre><code>  networks: {
    test: {
      host: &quot;127.0.0.1&quot;,
      port: 7545,
      network_id: &quot;*&quot;
    }
  }
</code></pre><p>Then you can deploy your contract to your local network first:</p><pre><code>truffle migrate --network test
</code></pre><p>You can interact with your contract by running the truffle console:</p><pre><code>truffle console --network test
truffle(test)&gt; contract = await HelloWorld.deployed()
undefined
truffle(test)&gt; contract.getName()
&#x27;Celo&#x27;
truffle(test)&gt; contract.setName(&#x27;MyName&#x27;)
{ tx:
...
truffle(test)&gt; contract.getName()
&#x27;MyName&#x27;
</code></pre><h2>Deploy to Alfajores</h2><p>When you are ready to deploy your contract to Alfajores, you&#x27;ll need a Celo client connected to the testnet. We&#x27;ll run a node somewhat similarly to the <a href="/getting-started/baklava-testnet/running-a-full-node-in-baklava">Instructions of running a full node on Baklava</a>:</p><pre><code class="language-bash">export CELO_IMAGE=us.gcr.io/celo-org/geth:alfajores
</code></pre><h3>Pull the Celo Docker image</h3><p>We&#x27;re going to use a Docker image containing the Celo node software in this tutorial.</p><p>If you are re-running these instructions, the Celo Docker image may have been updated, and it&#x27;s important to get the latest version.</p><pre><code class="language-bash">docker pull $CELO_IMAGE
</code></pre><h3>Set up a data directory</h3><p>First, create the directory that will store your node&#x27;s configuration and its copy of the blockchain. This directory can be named anything you&#x27;d like, but here&#x27;s a default you can use. The commands below create a directory and then navigate into it. The rest of the steps assume you are running the commands from inside this directory.</p><pre><code class="language-bash">mkdir celo-data-dir
cd celo-data-dir
</code></pre><h3>Create an account and get its address</h3><p>In this step, you&#x27;ll create an account on the network. If you&#x27;ve already done this and have an account address, you can skip this and move on to configuring your node.</p><p>Run the command to create a new account:</p><pre><code class="language-bash">docker run -v $PWD:/root/.celo --rm -it $CELO_IMAGE account new
</code></pre><p>It will prompt you for a passphrase, ask you to confirm it, and then will output your account address: <code>Address: {&lt;YOUR-ACCOUNT-ADDRESS&gt;</code></p><p>Save this address to an environment variables, so that you can reference it below (don&#x27;t include the braces):</p><pre><code class="language-bash">export CELO_ACCOUNT_ADDRESS=&lt;YOUR-ACCOUNT-ADDRESS&gt;
</code></pre><p><em>Note: this environment variable will only persist while you have this terminal window open. If you want this environment variable to be available in the future, you can add it to your `~/.bash_profile</em></p><h3>Start the node</h3><p>This command specifies the settings needed to run the node, and gets it started.</p><pre><code class="language-bash">docker run --name celo-ultralight-node -d --restart unless-stopped -p 127.0.0.1:8545:8545 -v $PWD:/root/.celo $CELO_IMAGE --verbosity 3  --syncmode lightest --http --http.addr 0.0.0.0 --http.api eth,net,web3,debug,admin,personal --etherbase $CELO_ACCOUNT_ADDRESS --alfajores --datadir=/root/.celo --allow-insecure-unlock
</code></pre><p>You can follow the logs with</p><pre><code class="language-bash">docker logs -f celo-ultralight-node
</code></pre><p>After a few seconds of syncing (with <a href="/celo-codebase/protocol/consensus/ultralight-sync">Celo&#x27;s ultralight sync</a>), you should be able to query the balance of your account:</p><pre><code class="language-bash">docker exec celo-ultralight-node geth attach --exec &#x27;eth.getBalance(&quot;&lt;YOUR-ACCOUNT-ADDRESS&gt;&quot;)&#x27;
</code></pre><p>If you go to our <a href="https://celo.org/build/faucet">Alfajores Faucet Page</a>, you should be able to faucet your account some CELO and see your balance increase with the above command.</p><h3>Deploy the contract</h3><p>We are finally ready to deploy the contract. First let&#x27;s unlock the account:</p><pre><code class="language-bash">docker exec celo-ultralight-node geth attach --exec &#x27;personal.unlockAccount(&quot;&lt;YOUR-ACCOUNT-ADDRESS&gt;&quot;, &quot;&lt;YOUR-ACCOUNT-PASSWORD&gt;&quot;)&#x27;
</code></pre><p>In your <code>truffle-config.js</code> reference your node:</p><pre><code>alfajores: {
  host: &quot;127.0.0.1&quot;,
  port: 8545,
  network_id: 44787
}
</code></pre><p>Then you should be able to deploy your contract with:</p><pre><code>truffle migrate --network alfajores
</code></pre><p>You can verify your contract deployment on <a href="https://alfajores-blockscout.celo-testnet.org/">Blockscout</a>, as well as interact with your new contract with the <code>truffle console --network alfajores</code>. Congratulations!</p><p>As you can see, all the goodies from Ethereum apply to Celo, so virtually all tutorials and other content should be easily translatable to Celo. Check out <a href="https://celo.org/build">https://celo.org/build</a> for more resources!</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Sending CELO & Stable Assets]]></title>
            <link>https://docs.lmax.pro/blog/developer-guide/start/hellocelo</link>
            <guid>/developer-guide/start/hellocelo</guid>
            <pubDate>Sat, 01 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[How to connect to the Celo test network and tranfer tokens using ContractKit.]]></description>
            <content:encoded><![CDATA[<p>How to connect to the Celo test network and tranfer tokens using ContractKit.</p><h2>Hello Celo: sending value with Celo</h2><p>In this guide we are going to write a Node.js script to introduce some of the basic concepts that are important to understand how Celo works. This will get us started with connecting to the Celo network and learning how to develop more advanced applications.</p><p>:::info</p><p>We assume you already have Node.js and NPM installed on your computer.</p><p>:::</p><h2>Learning Objectives</h2><p>At the end of this guide, you will be able to:</p><ul><li>Connect to the Celo test network, called Alfajores</li><li>Get test CELO, Celo Dollars (cUSD) and Celo Euros (cEUR) from the faucet</li><li>Read account and contract information from the test network</li><li>Transferring CELO, cUSD and cEUR on the test network</li></ul><h2>Getting Started</h2><p>To start, <a href="https://github.com/critesjosh/helloCelo">clone this GitHub repo</a>. This is a Node.js application.</p><pre><code>git clone https://github.com/critesjosh/helloCelo.git
</code></pre><p>We will be using the Celo ContractKit SDK to interact with the Celo test network (Alfajores). Let&#x27;s install it. It is already defined in the package.json, so we can get it with</p><pre><code>cd helloCelo
npm install
</code></pre><h2>Importing ContractKit</h2><p>We will be writing our Node.js app in the <code>helloCelo.js</code> file.</p><p>Import the contract kit into our script with</p><pre><code class="language-javascript" metastring="title=&quot;helloCelo.js&quot;" title="&quot;helloCelo.js&quot;">// 1. Import web3 and contractkit
const Web3 = require(&quot;web3&quot;);
const ContractKit = require(&quot;@celo/contractkit&quot;);
</code></pre><p>Now we can use the ContractKit to connect to the test network.</p><pre><code class="language-javascript" metastring="title=&quot;helloCelo.js&quot;" title="&quot;helloCelo.js&quot;">// 2. Init a new kit, connected to the alfajores testnet
const web3 = new Web3(&quot;https://alfajores-forno.celo-testnet.org&quot;);
const kit = ContractKit.newKitFromWeb3(web3);
</code></pre><p>:::info</p><p>At any point in the file you can <code>console.log()</code> variables to print their output when you run the script.</p><p>:::</p><h2>Reading Alfajores</h2><p>ContractKit contains a <code>contracts</code> property that we can use to access certain information about deployed Celo contracts.</p><p>:::info</p><p>The Celo blockchain has two native assets, CELO <!-- -->(<!-- -->CELO<!-- -->)<!-- --> and the Celo Dollar <!-- -->(<!-- -->cUSD<!-- -->)<!-- -->. Both of these assets implement the <a href="https://eips.ethereum.org/EIPS/eip-20">ERC20 token standard</a> from Ethereum. The CELO asset is managed by the CELO smart contract and Celo Dollars is managed by the cUSD contract. We can access the CELO contract via the SDK with <code>kit.contracts.getGoldToken()</code> and the cUSD contract with <code>kit.contracts.getStableToken()</code>. These functions return promises, so we have to wait for them to resolve before we can interact with the token contracts. If you are unfamiliar with Promises in Javascript, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">check out this documentation.</a> Promises are a common tool in blockchain development. In this guide, we use the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await">async/await syntax for promises</a>.</p><p>:::</p><p>Let&#x27;s read some token balances from the blockchain. Add the following line in the <code>readAccount()</code> function.</p><pre><code class="language-javascript" metastring="title=&quot;helloCelo.js&quot;" title="&quot;helloCelo.js&quot;">// 3. Get the token contract wrappers
let celotoken = await kit.contracts.getGoldToken();
let cUSDtoken = await kit.contracts.getStableToken();
let cEURtoken = await kit.contracts.getStableToken(&quot;cEUR&quot;);
</code></pre><p>We can get the CELO balance of an account using the token wrappers like <code>goldtoken.balanceOf(address)</code>. Let&#x27;s check the balance of this address <code>&#x27;0xD86518b29BB52a5DAC5991eACf09481CE4B0710d&#x27;</code>.</p><pre><code class="language-javascript" metastring="title=&quot;helloCelo.js&quot;" title="&quot;helloCelo.js&quot;">// 4. Address to look up
let anAddress = &quot;0xD86518b29BB52a5DAC5991eACf09481CE4B0710d&quot;;

// 5. Get token balances
let celoBalance = await celotoken.balanceOf(anAddress);
let cUSDBalance = await cUSDtoken.balanceOf(anAddress);
let cEURBalance = await cEURtoken.balanceOf(anAddress);

// Print balances
console.log(`${anAddress} CELO balance: ${celoBalance.toString()}`);
console.log(`${anAddress} cUSD balance: ${cUSDBalance.toString()}`);
console.log(`${anAddress} cEUR balance: ${cEURBalance.toString()}`);
</code></pre><p>The <code>balanceOf(address)</code> function also returns a Promise, so we wait for the promise to resolve then we print the result.</p><p>To view the balances, run the script from the termainal with</p><pre><code>node helloCelo.js
</code></pre><p>:::info</p><p>Note that the <code>balanceOf()</code> function returns objects with type <a href="https://github.com/MikeMcl/bignumber.js/">BigNumber</a> because balances are represented in Celo as a 256 bit unsigned integer, and JavaScript&#x27;s number type cannot safely handle numbers of that size. Note also that the balance values are reported in units of CELO Wei, where one CELO = 10<!-- -->*<!-- -->*<!-- -->18 CELO Wei.</p><p>:::</p><p>Reading all account balances is a powerful feature of blockchains. Next, let&#x27;s see how we can send value to each other on the testnet.</p><p>In order to do transfers (aka <a href="https://docs.celo.org/getting-started/glossary#transaction">transactions</a>), we need to:</p><ol><li>Create an <a href="https://docs.celo.org/getting-started/glossary#account">account</a> <!-- -->(<!-- -->by creating a private key<!-- -->)</li><li>Fund it with test CELO and cUSDs</li><li>Sign and send transactions to the network</li></ol><h2>Accounts</h2><p>We are accessing the Celo network via a remote <a href="https://docs.celo.org/getting-started/glossary#node">node</a> via HTTP requests at <code>&#x27;https://alfajores-forno.celo-testnet.org&#x27;</code>.</p><p>:::info</p><p>Don&#x27;t worry about what this means right now, just understand that it is easier to get started using Celo by accessing remote nodes, rather than running them locally on your machine. You can <a href="https://github.com/critesjosh/celo-monorepo/tree/8542c1bc3ad32bc48eed33073f4d34a36fd91fae/packages/docs/celo-sdk/walkthroughs/overview.md#topology-of-a-celo-network">read more about the details of the Celo network here.</a></p><p>:::</p><p>Because we are accessing the network remotely, we need to generate an account to sign transactions and fund that account with test CELO.</p><p>There is a short script in <code>getAccount.js</code> to either get a Celo account from a mnemonic in the <code>.secret</code> file, or create a random account if the file is empty. In the script, we use<code>web3.js</code> to create a new private key/account pair. <a href="https://web3js.readthedocs.io/">Web3.js</a> is a popular javascript library for handling Ethereum related functionality. Celo is a cousin of Ethereum, so this library works well for generating Celo accounts.</p><p>:::danger</p><p>This is not the standard way of managing Celo accounts. In a production environment, the <a href="/celo-codebase/wallet">Celo Wallet</a> will manage accounts for you. Accessing accounts from the Celo Wallet will be discussed in future guides.</p><p>:::</p><p>We can now use this <code>account</code> to get account information <!-- -->(<!-- -->ie the private key and account address<!-- -->)<!-- --> and to send transactions from <code>account.address</code>. Add the following code to read the account balance. Continue adding to <code>helloCelo.js</code>.</p><pre><code class="language-javascript" metastring="title=&quot;helloCelo.js&quot;" title="&quot;helloCelo.js&quot;">//
// Create an Account
//

// 6. Import the getAccount function
const getAccount = require(&quot;./getAccount&quot;).getAccount;

async function getBalances() {
  // 7. Get your account
  let account = await getAccount();

  // 8. Get the token contract wrappers
  let celotoken = await kit.contracts.getGoldToken();
  let cUSDtoken = await kit.contracts.getStableToken();
  let cEURtoken = await kit.contracts.getStableToken(&quot;cEUR&quot;);

  // 9. Get your token balances
  let celoBalance = await celotoken.balanceOf(account.address);
  let cUSDBalance = await cUSDtoken.balanceOf(account.address);
  let cEURBalance = await cEURtoken.balanceOf(account.address);

  // Print your account info
  console.log(`Your account address: ${account.address}`);
  console.log(`Your account CELO balance: ${celoBalance.toString()}`);
  console.log(`Your account cUSD balance: ${cUSDBalance.toString()}`);
  console.log(`Your account cEUR balance: ${cEURBalance.toString()}`);
}
</code></pre><p>Run this script again with <code>node helloCelo.js</code>. This will print <code>0</code>, as we have not funded the associated account yet.</p><h2>Using the faucet</h2><p>We can get free test CELO and cUSDs on the test network for development via <a href="https://celo.org/build/faucet">the Celo Alfajores faucet</a>.</p><p>Copy your randomly generated account address from the console output mentioned above, and paste it into the faucet.</p><p>Once your account has been funded, run <code>$ node helloCelo.js</code> again to see your updated balance.</p><h2>Sending Value</h2><p>We have an account with CELO and cUSD in it, now how do we send tokens to another account? Remember the token wrappers we used to read account balances earlier? We can use the same wrappers to send tokens, you just need to add the private key associated with your account to ContractKit <!-- -->(<!-- -->see line 10<!-- -->)<!-- -->.</p><p>The token wrappers have a method called <code>transfer(address, amount)</code> that allows you to send value to the specified address <!-- -->(<!-- -->line 14<!-- -->)<!-- -->.</p><p>You need to <code>send()</code> the transaction to the network after you construct it. The <code>send()</code> methods accepts an option that allows you to specify the <code>feeCurrency</code>, which allows the sender to pay transaction fees in CELO or cUSD. The default <code>feeCurrency</code> is CELO. In the following example, let&#x27;s pay transaction fees in CELO when we transfer CELO and pay with cUSD when we transfer cUSD.</p><p>The <code>send()</code> method returns a transaction object. We will wait for the transaction receipt <!-- -->(<!-- -->which will be returned when the transaction has been included in the blockchain<!-- -->)<!-- --> and print it when we get it. This receipt contains information about the transaction.</p><p>After we read the receipt, we check the balance of our account again, using the <code>balanceOf()</code> function. The logs print our updated balance!</p><p>You may notice that the account balance is a bit smaller than the amount of tokens that we sent. This is because you have to pay for every update to the network.</p><p>Add the following code to the <code>send()</code> function in <code>helloCelo.js</code> to send a transaction.</p><pre><code class="language-javascript" metastring="title=&quot;helloCelo.js&quot;" title="&quot;helloCelo.js&quot;">async function send() {
  // 10. Get your account
  let account = await getAccount();

  // 11. Add your account to ContractKit to sign transactions
  kit.connection.addAccount(account.privateKey);

  // 12. Specify recipient Address
  let anAddress = &quot;0xD86518b29BB52a5DAC5991eACf09481CE4B0710d&quot;;

  // 13. Specify an amount to send
  let amount = 100000;

  // 14. Get the token contract wrappers
  let celotoken = await kit.contracts.getGoldToken();
  let cUSDtoken = await kit.contracts.getStableToken();
  let cEURtoken = await kit.contracts.getStableToken(&quot;cEUR&quot;);

  // 15. Transfer CELO and cUSD from your account to anAddress
  // Optional: specify the feeCurrency, default feeCurrency is CELO
  let celotx = await celotoken
    .transfer(anAddress, amount)
    .send({ from: account.address });
  let cUSDtx = await cUSDtoken
    .transfer(anAddress, amount)
    .send({ from: account.address, feeCurrency: cUSDtoken.address });
  let cEURtx = await cEURtoken
    .transfer(anAddress, amount)
    .send({ from: account.address });

  // 16. Wait for the transactions to be processed
  let celoReceipt = await celotx.waitReceipt();
  let cUSDReceipt = await cUSDtx.waitReceipt();
  let cEURReceipt = await cEURtx.waitReceipt();

  // 17. Print receipts
  console.log(&quot;CELO Transaction receipt: %o&quot;, celoReceipt);
  console.log(&quot;cUSD Transaction receipt: %o&quot;, cUSDReceipt);
  console.log(&quot;cEUR Transaction receipt: %o&quot;, cEURReceipt);

  // 18. Get your new balances
  let celoBalance = await celotoken.balanceOf(account.address);
  let cUSDBalance = await cUSDtoken.balanceOf(account.address);
  let cEURBalance = await cEURtoken.balanceOf(account.address);

  // 19. Print new balance
  console.log(`Your new account CELO balance: ${celoBalance.toString()}`);
  console.log(`Your new account cUSD balance: ${cUSDBalance.toString()}`);
  console.log(`Your new account cUSD balance: ${cEURBalance.toString()}`);
}
</code></pre><p>Run <code>$ node helloCelo.js</code> again to send the transactions and see the printed output in the console.</p><h2>Connecting to a Ledger Device from a Web Application</h2><p>The above instructions apply to building NodeJS applications. If you want to build an integration with a web application, you can still use the ContractKit by following slightly modified instructions.</p><p>The following code examples are typescript so should be stored in a <code>.tsc</code> file, you will also need to install typescript and then compile your typescript to javascript with <code>npx tsc</code> before you can run the code with node.</p><pre><code>npm install --save-dev typescript
npm install web3 @celo/contractkit @celo/wallet-ledger @ledgerhq/hw-app-eth @ledgerhq/hw-transport-u2f @ledgerhq/hw-transport-webusb
</code></pre><p>Then, you can create a new instance of the ContractKit with the following code:</p><pre><code class="language-javascript">import { ContractKit, newKitFromWeb3 } from &quot;@celo/contractkit&quot;;
import { newLedgerWalletWithSetup } from &quot;@celo/wallet-ledger&quot;;
import Eth from &quot;@ledgerhq/hw-app-eth&quot;;
import TransportU2F from &quot;@ledgerhq/hw-transport-u2f&quot;;
import TransportUSB from &quot;@ledgerhq/hw-transport-webusb&quot;;
import Web3 from &quot;web3&quot;;

// Handle getting the Celo Ledger transport.
const getCeloLedgerTransport = () =&gt; {
  if (window.USB) {
    return TransportUSB.create();
  } else if (window.u2f) {
    return TransportU2F.create();
  }

  throw new Error(
    &quot;Ledger Transport not support, please use Chrome, Firefox, Brave, Opera or Edge.&quot;
  );
};

// Handle creating a new Celo ContractKit
const getContractKit = async () =&gt; {
  // Create a Web3 provider by passing in the testnet/mainnet URL
  const web3 = new Web3(&quot;https://alfajores-forno.celo-testnet.org&quot;);

  // Get the appropriate Ledger Transport
  const transport = await getCeloLedgerTransport();

  // Create a new instance of the ETH Ledger Wallet library
  const eth = new Eth(transport);

  // Use the Celo Ledger Wallet setup util
  const wallet = await newLedgerWalletWithSetup(eth.transport);

  // Instantiate the ContractKit
  const kit: ContractKit = newKitFromWeb3(web3, wallet);

  return kit;
};
</code></pre><p>Once you have successfully created the ContractKit, you can use the various Celo contracts to sign transactions with a connected Ledger device. For example, here&#x27;s how to transfer gold tokens (just like above in the NodeJS example):</p><pre><code class="language-javascript">// Use the gold token contract to transfer tokens
const transfer = async (from, to, amount) =&gt; {
  const celoTokenContract = await kit.contracts.getGoldToken();
  const tx = await celoTokenContract.transfer(to, amount).send({ from });
  const receipt = await tx.waitReceipt();
  console.log(&quot;Transaction Receipt: &quot;, receipt);
};
</code></pre><p>This is the basic setup to integrate the Celo Ledger App with a web application. You can also view the <a href="https://github.com/celo-org/celo-ledger-web-app">Celo Ledger App example codebase</a> for some other examples of connecting to a Ledger Device from a web application.</p><h2>Wrapping Up</h2><p>Congratulations! You have accomplished a lot in this short introduction to developing on Celo.</p><p>We covered:</p><ul><li>Installing and setting up ContractKit</li><li>Connecting to the Celo Alfajores network</li><li>Getting the CELO contract wrapper</li><li>Reading account balances using the CELO wrapper</li><li>Generating a new account in Celo</li><li>Funding an account using the Celo Alfajores Faucet</li><li>Sending CELO</li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Using Keystores Library for Local Key Management]]></title>
            <link>https://docs.lmax.pro/blog/developer-guide/start/using-js-keystores</link>
            <guid>/developer-guide/start/using-js-keystores</guid>
            <pubDate>Fri, 31 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[Introduction to the keystores library and how to use it for local key management.]]></description>
            <content:encoded><![CDATA[<p>Introduction to the keystores library and how to use it for local key management.</p><h2>Getting Started</h2><p>This is a JavaScript library that provides functions for creating and interacting with encrypted keystores for private key management. To do this, this library wraps the existing <a href="https://github.com/ethereumjs/ethereumjs-wallet"><code>ethereumjs-wallet</code> library</a>, which is a standard library for managing keystores according to the <a href="https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition">Web3 Secret Storage Definition</a>. As specified, secrets are encrypted using the Scrypt KDF (Key Derivation Function); in this case, the private key is encrypted with a passphrase (that should be kept secret) and can be decrypted later by the same phrase. Note that a keystore generated for the same (private key, passphrase) multiple times will not yield the same output due to how the KDF works. Keystore files generated by a geth node can be decrypted and accessed with this library, and vice versa.</p><p><strong>Note that keystore files generated by this library do not contain BLS public keys, meaning that these should not be used for validator signer keys used in consensus.</strong></p><p>The components of the library are roughly as follows:</p><ul><li><code>KeystoreBase</code> which wraps the functionality of <code>ethereumjs-wallet</code> and exposes functions to:<ul><li>import PKs (into encrypted keystores)</li><li>decrypt and get a PK from an encrypted keystore</li><li>change the passphrase on a keystore</li></ul></li><li><code>FileKeystore</code>, <code>InMemoryKeystore</code> which specifiy the IO in addition to the above base class</li><li><code>KeystoreWalletWrapper</code>: (not stable; likely to structurally change) a very simple wrapper for a <code>Keystore</code> and <code>LocalWallet</code>, which allows a user to decrypt a keystore and pass the key to the <code>LocalWallet</code> in order to sign transactions.</li></ul><h2>Usage</h2><p>:::warning</p><p>For accounts containing significant funds or otherwise requiring a high degree of security, we <strong>do not</strong> recommend this keystore library! This is only for managing keys for low-risk hot wallets and signers.</p><p>For more stringent security requirements, check out the guide to <a href="/getting-started/wallets">Choosing a Wallet</a>.</p><p>:::</p><p>Depending on your use case, you can either interact directly with the <code>FileKeystore</code> (purely for creating and interacting with keystore files, importing or accessing private keys) or else use the <code>KeystoreWalletWrapper</code> (combines the keystore functionality with convenient access to the <code>LocalWallet</code> for signing tranactions).</p><h3>Using the FileKeystore</h3><h4>Create new keystore and import private key</h4><p>This snippet will create a <code>keystore</code> directory in the <code>parentDirectory</code> and create an encrypted file in the <code>keystore</code> directory containing the private key. Note that you can only create a new encrypted file for a private key if there is not already an existing file for that private key. If it already exists, you can change the passphrase (see below), but you may not have multiple files for the same private key in the same <code>keystore</code> directory.</p><pre><code class="language-js">import * as readline from &quot;readline&quot;;
import { FileKeystore } from &quot;@celo/keystores&quot;;

// This is the directory that will contain a &quot;keystore&quot; directory
const parentDirectory = &quot;&lt;INSERT_PATH_HERE&gt;&quot;;
// This creates a &quot;keystore&quot; directory if one does not already exist in the parentDirectory
const keystore = new FileKeystore(parentDirectory);

// Prompt to enter private key and passphrase on the command line
let rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});
const privateKey: string = await new Promise((resolve) =&gt;
  rl.question(&quot;Enter private key:&quot;, (answer) =&gt; {
    resolve(answer);
  })
);
const passphrase: string = await new Promise((resolve) =&gt;
  rl.question(&quot;Enter secret passphrase:&quot;, (answer) =&gt; {
    rl.close();
    resolve(answer);
  })
);
// Import private key into the keystore, which is then stored as an encrypted file
// Should create a file with a name like `UTC-&lt;DATETIME&gt;-&lt;ACCOUNT_ADDRESS&gt;`
await keystore.importPrivateKey(privateKey, passphrase);
// Retrieve all addresses contained in the keystore
console.log(&quot;Addresses in keystore: &quot;, await keystore.listKeystoreAddresses());
</code></pre><h4>Accessing an existing keystore file</h4><pre><code class="language-js">// Keystore already exists
const parentDirectory = &#x27;&lt;INSERT_PATH_HERE&gt;&#x27;
const keystore = new FileKeystore(parentDirectory)
const address = &#x27;&lt;YOUR_ADDRESS_HERE&gt;&#x27;
const oldPassphrase = &#x27;&lt;OLD_PASSPHRASE&gt;&#x27;

// Decrypt file and retrieve private key
await keystore.getPrivateKey(address, oldPassphrase)

// Change the passphrase encrypting the file
const newPassphrase = &#x27;&lt;NEW_PASSPHRASE&gt;&#x27;
await.keystore.changeKeystorePassphrase(address, oldPassphrase, newPassphrase)

// Decrypt file and retrieve private key using new passphrase
console.log(await keystore.getPrivateKey(address, newPassphrase))
</code></pre><h4>Remove (delete) a keystore file for a particular address</h4><pre><code class="language-js">const parentDirectory = &quot;&lt;INSERT_PATH_HERE&gt;&quot;;
const keystore = new FileKeystore(parentDirectory);
const address = &quot;&lt;YOUR_ADDRESS_HERE&gt;&quot;;

// When you know the address
// Get the filename (keystore name)
const keystoreName = await keystore.getKeystoreName(address);
await keystore.removeKeystore(keystoreName);

// Alternatively, you can do this by passing in the filename directly
keystore.removeKeystore(&quot;&lt;KEYSTORE_FILENAME_TO_DELETE&gt;&quot;);
</code></pre><h3>Using the KeystoreWalletWrapper</h3><p>This example will instantiate a <code>KeystoreWalletWrapper</code>, import a private key, and use the inner <code>LocalWallet</code> within the wrapper to sign and send a transaction with <code>ContractKit</code>.</p><pre><code class="language-js">import { newKit } from &quot;@celo/contractkit&quot;;
import { FileKeystore, KeystoreWalletWrapper } from &quot;@celo/keystores&quot;;

// This is the directory that will contain a &quot;keystore&quot; directory
const parentDirectory =
  &quot;/celo/celo-monorepo/packages/sdk/wallets/wallet-keystore/test-keystore-dir&quot;;
// Instantiate a KeystoreWalletWrapper using a FileKeystore
const keystoreWalletWrapper = new KeystoreWalletWrapper(
  new FileKeystore(parentDirectory)
);
// Make sure to not commit this if using real funds!
// You can also get this as input on the command-line using `readline`
// as in the example above for FileKeystore
const privateKey = &quot;YOUR_TEST_PRIVATE_KEY&quot;;
const passphrase = &quot;test-passphrase1! &quot;;

// Import private key or unlock account
await keystoreWalletWrapper.importPrivateKey(privateKey, passphrase);
// If the keystore file already exists for an address, simply unlock:
// const address = &#x27;YOUR_TEST_ADDRESS&#x27;
// await keystoreWalletWrapper.unlockAccount(address, passphrase)

// Get the wrapper&#x27;s `LocalWallet` instance and pass this into ContractKit
const wallet = keystoreWalletWrapper.getLocalWallet();
const kit = newKit(&quot;https://alfajores-forno.celo-testnet.org&quot;, wallet);
const [from] = wallet.getAccounts();

// Send a test transaction
const gold = await kit.contracts.getGoldToken();
await gold
  .transfer(&quot;0x22579ca45ee22e2e16ddf72d955d6cf4c767b0ef&quot;, &quot;1&quot;)
  .sendAndWaitForReceipt({ from });
console.log(&quot;Transaction sent!&quot;);
</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Add Your ERC20 Token to Your Celo Wallet]]></title>
            <link>https://docs.lmax.pro/blog/add-token-celo-wallet</link>
            <guid>add-token-celo-wallet</guid>
            <pubDate>Mon, 06 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[Learn How to Add Your ERC20 Token to Your Celo Wallet]]></description>
            <content:encoded><![CDATA[<p>If you are trying to add your own token please make sure you have already read Josh&#x27;s tutorial on <a href="https://docs.celo.org/developer-resources/walkthroughs/no-code-erc20">how to make your own ERC20 Token on Celo</a>.</p><p>Now that you’ve made your own ERC20 Token, you will want to have it displayed in your Celo Wallet. If you don’t currently have Celo Wallet you will need to <a href="https://celowallet.app/setup">download it</a> first.</p><p>1) Open up Cello Wallet and make sure you can see “Account Balance Details” then select “Add a new currency/token.”</p><p><img src="https://user-images.githubusercontent.com/93226346/144902366-42169908-95e8-4d0a-a6d8-b6ad021394cf.png" alt="Photo"/></p><p>If you don’t see the above screen then click the green “More” button in the upper left of the Celo Wallet app.</p><p><img src="https://user-images.githubusercontent.com/93226346/144900620-2ed8b9a1-513e-4a8b-a95a-9542c97c2908.png" alt="Photo"/></p><p>Then select &quot;Balance - View Balances&quot;</p><p><img src="https://user-images.githubusercontent.com/93226346/144900692-5a213c05-a99e-408b-97c9-7aeed41d870c.png" alt="Photo"/></p><p>2) Copy your token’s address and paste it into the “Token name or address” text field. If you don’t remember your Token’s address you can search for it by name on <a href="https://explorer.celo.org/">Celo’s Explorer</a>.</p><p><img src="https://user-images.githubusercontent.com/93226346/144900871-cc2ffa50-d7f2-46c3-94dd-15126d71f57b.png" alt="Photo"/></p><p>3) Click “Add” and you should then see the token listed. The token I added for this example is “BCN.” If you look to the far right you’ll see that only “BCN” has an “X” after its address. This is because I manually added “BCN” and the other listed coins are native assets from Celo.</p><p><img src="https://user-images.githubusercontent.com/93226346/144901070-cc1e1317-d2ab-4279-8c83-dd62072b9987.png" alt="Photo"/></p><p>4) If you wish to send your token to another Celo Wallet click the green “Send” button in the upper left.</p><p><img src="https://user-images.githubusercontent.com/93226346/144901103-72335db9-7806-40e4-bdad-11a8c8ad51b6.png" alt="Photo"/></p><p>5) Enter the recipient’s address and select your token from the Currency dropdown. You can then enter the amount of tokens you wish to send.</p><p><img src="https://user-images.githubusercontent.com/93226346/144901137-2b679ac6-24ea-4947-80fd-4fab1d3b76cd.png" alt="Photo"/></p><p>6) You’ll be charged a fee in Celo for your transaction. Make sure you are sending this to another Cello Wallet! If the address, token and amount are all correct click “Send Payment.”</p><p><img src="https://user-images.githubusercontent.com/93226346/144901189-2f9adb93-9cce-48ff-8e4d-1476b75f1fec.png" alt="Photo"/></p><p>Congratulations! You’ve just sent your own token to somebody! Your token should be automatically added to their list. If for some reason it is not automatically added, they can simply follow the above steps.</p><p>If you have any questions feel free to message me on Discord at vissequ#1301 or on Twitter at <a href="https://twitter.com/connorfabiano">@connorfabiano</a></p><p>(Tutorials for using different wallets such as Metamask will be added in the future.)</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Verifying Contracts with Hardhat]]></title>
            <link>https://docs.lmax.pro/blog/hardhat-deploy-verify</link>
            <guid>hardhat-deploy-verify</guid>
            <pubDate>Tue, 30 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[Learn to verify contracts on Sourcify using the hardhat-deploy plugin]]></description>
            <content:encoded><![CDATA[<p>Hardhat is one of the most popular developer tools for writing contracts for EVM compatible blockchains. Hardhat is a great tool for developing smart contracts for Celo--you can find more information about this in the Celo documentation <a href="/developer-resources/deploy-hardhat">here</a>.</p><p>In this tutorial I will go over how to use the <a href="https://github.com/wighawag/hardhat-deploy">hardhat-deploy plugin</a> for hardhat, specifically to verify deployed contracts on the <a href="https://explorer.celo.org/">Celo block explorer</a> via <a href="https://sourcify.dev/">Sourcify</a>. You can verify contracts with the plugin whether you deployed them using the plugin or not.</p><p>In this post I will cover</p><ul><li>setting up a hardhat project with the hardhat-deploy plugin</li><li>deploying contracts using the plugin</li><li>how to verify the contracts on sourcify</li></ul><h2>Verify contracts using hardhat-deploy</h2><h3>Setup</h3><p>First, I will cover how to deploy contracts using the plugin. This will help provide some context around how a project using this plugin is different from a regular hardhat project. This guide assumes that you already have a hardhat project set up. If you don’t, refer to <a href="https://docs.celo.org/developer-resources/deploy-hardhat">this page</a>.</p><p>:::tip</p><p>You can reference the &#x27;hardhat-deploy&#x27; branch of <a href="https://github.com/critesjosh/celo-hardhat/tree/hardhat-deploy">this github repo</a> to see how the project is structured.</p><p>:::</p><p>Install the plugin in your hardhat project:</p><pre><code class="language-shell">npm install -D hardhat-deploy
</code></pre><p>Import the plugin in your <code>hardhat.config.js</code> file.</p><pre><code class="language-js">require(&#x27;hardhat-deploy&#x27;);
</code></pre><p>Since <code>hardhat-deploy-ethers</code> is a fork of <code>@nomiclabs/hardhat-ethers</code> and that other plugin might have an hardcoded dependency on <code>@nomiclabs/hardhat-ethers</code> the best way to install <code>hardhat-deploy-ethers</code> and ensure compatibility is the following:</p><pre><code class="language-shell">npm install --save-dev  @nomiclabs/hardhat-ethers@npm:hardhat-deploy-ethers ethers
</code></pre><p>Which means you then need to do <code>require(&quot;@nomiclabs/hardhat-ethers&quot;)</code> instead of <code>require(&quot;hardhat-deploy-ethers&quot;)</code> in your <code>hardhat.config.js</code> file.</p><p>The plugin also supports Typescript, which you can find more information about <a href="https://github.com/wighawag/hardhat-deploy#typescript-support">here</a>.</p><p>The plugin also has a concept of <code>namedAccounts</code> which makes it easier to reference available accounts. You can read more about the details <a href="https://github.com/wighawag/hardhat-deploy#1-namedaccounts-ability-to-name-addresses">here</a>. For our purposes, keep it simple and add <code>namedAccounts</code> to the exports in <code>hardhat.config.js</code> like so</p><pre><code class="language-js">//hardhat.config.js
...
module.exports = {
 defaultNetwork: &quot;alfajores&quot;,
 namedAccounts: {
   deployer: 0
 },
 networks: {
...
</code></pre><p>You can see my source file <a href="https://github.com/critesjosh/celo-hardhat/blob/085cf7bc304ec3b0924de1419fe32e37b57e7185/hardhat.config.js#L23">here</a>.  </p><h3>Deploy</h3><p>Deployment scripts used by <code>hardhat-deploy</code> live in a folder called <code>deploy</code> in the root of the project. The deployment scripts will save deployment information in a <code>deployments</code> folder in the project root as well.</p><p><a href="https://github.com/critesjosh/celo-hardhat/blob/hardhat-deploy/deploy/00-deploy.js">Here</a> is the deployment script for deploying the <a href="https://github.com/critesjosh/celo-hardhat/blob/hardhat-deploy/contracts/Greeter.sol">Greeter contract</a> in the example repo.</p><pre><code class="language-js">// deploy/00_deploy_my_contract.js
module.exports = async ({getNamedAccounts, deployments}) =&gt; {
   const {deploy} = deployments;
   const {deployer} = await getNamedAccounts();
   await deploy(&#x27;Greeter&#x27;, {
     from: deployer,
     args: [&quot;hello world&quot;],
     log: true,
   });
 };
 module.exports.tags = [&#x27;Greeter&#x27;];
</code></pre><p>It is a simple function that takes the <code>namedAccounts</code>, configuration info and the contract constructor arguments and deploys the contract. You can read more about deploy scripts <a href="https://github.com/wighawag/hardhat-deploy#deploy-scripts">here</a>.</p><p>To run the deployment, use the command</p><pre><code class="language-bash">npx hardhat --network alfajores deploy
</code></pre><p>There should be terminal output similar to this:</p><pre><code class="language-shell">Downloading compiler 0.8.4
Compiling 1 file with 0.8.4
Compilation finished successfully
deploying &quot;Greeter&quot; (tx: 0x7fedbd14877cdca23485a96108e22ae6764b65348eddbaa1cbec9504707b7186)...: deployed at 0x9F163C9138faA5cdc731b94E1e9632C05764C23e with 493178 gas
</code></pre><h3>Verify</h3><p>Once the contract is deployed, you can verify it with the command:</p><pre><code class="language-shell">npx hardhat --network alfajores sourcify
</code></pre><p>Which should output</p><pre><code class="language-shell">verifying Greeter (0x9F163C9138faA5cdc731b94E1e9632C05764C23e on chain 44787) ...
 =&gt; contract Greeter is now verified
</code></pre><p>You can check the verification on the block explorer, <a href="https://alfajores-blockscout.celo-testnet.org/address/0x9F163C9138faA5cdc731b94E1e9632C05764C23e/contracts">https://alfajores-blockscout.celo-testnet.org/address/0x9F163C9138faA5cdc731b94E1e9632C05764C23e/contracts</a> in this case.</p><p>I hope this is helpful and feel free to <a href="https://chat.celo.org">join the Celo Discord</a> server and reach out if you have any questions. My handle is joshc#0001.</p><p>You can view my hardhat-deploy repository for reference on GitHub here: <a href="https://github.com/critesjosh/celo-hardhat/tree/hardhat-deploy">https://github.com/critesjosh/celo-hardhat/tree/hardhat-deploy</a></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Using the Graph w/ Celo]]></title>
            <link>https://docs.lmax.pro/blog/using-the-graph</link>
            <guid>using-the-graph</guid>
            <pubDate>Thu, 18 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[Learn about what the Graph is and how to use it in your Celo DApp]]></description>
            <content:encoded><![CDATA[<p><a href="https://thegraph.com/">The Graph protocol</a> makes it easy to get historical blockchain data. This can be useful when you want to check a users history of using a specific token or interacting with a specific contract. It may also be useful when collecting data about the activity around a specific contract, or set of contracts. The Graph also makes this data easy to transform, organize and share across applications.</p><p>In this post I explore</p><ul><li><a href="index.md#what-is-the-graph">What the Graph is</a></li><li><a href="index.md#using-the-graph">How to get started using the Graph with Celo</a></li><li><a href="index.md#initialize-your-subgraph">What a subgraph is and how to create one</a></li><li><a href="index.md#deploy-subgraph">How to deploy a subgraph to the Graph&#x27;s hosted service</a></li><li><a href="index.md#query-the-subgraph">How to query a subgraph</a></li></ul><h2>What is the Graph?</h2><p>From the Graph website:</p><p><em>The Graph is a decentralized protocol for indexing and querying data from blockchains, starting with Ethereum. It makes it possible to query data that is difficult to query directly.</em></p><p>The problem that the Graph solves is that indexing blockchain data is actually very difficult. Additionally, the Graph makes it easy to get historical blockchain data without having to run your own archive node or paying to access an archive node through a node service provider, like <a href="https://www.quicknode.com/chains/celo">Quicknode</a>.</p><h2>Using the Graph</h2><p>I will be using <a href="https://github.com/critesjosh/the-graph-hello-world">this GitHub repository</a> as a reference throughout this post. This repo contains a simple <a href="https://github.com/critesjosh/the-graph-hello-world/blob/master/HelloWorld.sol">HelloWorld contract</a> that stores a string that can be updated. </p><p><code>HelloWorld.sol</code></p><pre><code class="language-js">// HelloWorld.sol

// Learn more about Solidity here: https://solidity.readthedocs.io
pragma solidity &gt;=0.5.0;

contract HelloWorld {
  
  event NameUpdated(string newName, address updater);
  
  // Define a string called name
  string name;

  // Declares a function called getName
  // The &#x27;public&#x27; label means the function can be called internally, by transactions or other contracts
  // The &#x27;view&#x27; label indicates that the function does not change the state of the contract
  // The function returns a string, from the memory data location  
  function getName() 
    public 
    view 
    returns (string memory) 
  {
    // Return the storage variable &#x27;name&#x27;
    return name;
  }

  // Declare a function called setName
  // The function takes 1 parameter, a string, called newName, with the calldata data location in the Ethereum Virtual Machine  
  // The &#x27;external&#x27; label means the function can only be called from an external source
  function setName(string calldata newName) 
    external 
  {
    emit NameUpdated(newName, msg.sender);
    // Set the storage variable, name, to the value passed in as newName
    name = newName;
  }
}
</code></pre><p>The contract emits an event every time the storage sting is updated. Event handlers in the subgraph are triggered by contract events, so setting up a contract with events is required.</p><p>It is easiest to get started using the Graph hosted service, which supports queries on the Celo network.</p><p>:::tip</p><p>You can <a href="https://thegraph.com/docs/hostedservice/what-is-hosted-service">learn more about the Graph&#x27;s hosted service here</a>.</p><p>:::</p><h3>Install the Graph CLI</h3><p>The first step is to install the graph command line tool.</p><pre><code class="language-bash">npm install -g @graphprotocol/graph-cli
</code></pre><p>or</p><pre><code class="language-bash">yarn global add @graphprotocol/graph-cli
</code></pre><p>:::tip</p><p>Learn more about the <code>graph-cli</code> package <a href="https://www.npmjs.com/package/@graphprotocol/graph-cli">here</a>.</p><p>:::</p><h3>Initialize your Subgraph</h3><p><em>A subgraph defines which data The Graph will index from Ethereum, and how it will store it. Once deployed, it will form a part of a global graph of blockchain data.</em></p><p>:::tip</p><p><a href="https://thegraph.com/docs/developer/define-subgraph-hosted">Read more about subgraphs on the Graph website.</a></p><p>:::</p><p>In a new, empty project directory, run the following command in the terminal:</p><pre><code class="language-bash">graph init --product hosted-service --from-contract 0xd2dC7E59971E934bF479B8eA86B9Ec1627B0F3D6 --network celo-alfajores --abi &lt;FILE&gt; critesjosh/Hello-World
</code></pre><p>The CLI tool will prompt you for some additional information. Use the &quot;Hosted Service&quot; for creating subgraphs that query contracts on the Celo network.</p><p>For the subgraph name, enter your GitHub username followed by the name of your project. In my case this is <code>critesjosh/Hello-World</code>.</p><p>The tool will ask you to specify a directory, network and contract address that you would like to query. I chose the default directory (Hello-World), the <code>celo-alfajores</code> network, the address of my deployed Solidity contract and the path to my <a href="https://docs.soliditylang.org/en/latest/abi-spec.html">contract ABI</a>.</p><p>The tool sets up my subgraph in the specified directory. Open <code>subgraph.yml</code> in the new subgraph project folder to see how it is configured. You can find more information about the <a href="https://thegraph.com/docs/developer/create-subgraph-hosted#the-subgraph-manifest">Subgraph Manifest file here</a>.</p><h3>Define the schema</h3><p>The next step is to define your graphql schema in <code>schema.graphql</code> in the new project directory.</p><p>A graphql schema is like a dictionary that defines the types of entities to map from the data and how the entities are related. This is an important step to spend some time thinking about because this will define how your data is structured and linked. Here is <a href="https://github.com/sushiswap/sushiswap-subgraph">sushiswap&#x27;s subgraph repo</a> as a complex project reference.</p><p>For the simple HelloWorld contract that we are querying with this subgraph, I defined the schema like this:</p><pre><code class="language-graphql">type Name @entity {
  id: ID!
  newName: String
  updater: Bytes!
}
</code></pre><p>This will tell us the new name that is being stored in the contract, <code>newName</code>, and the account address that updated the name, <code>udpater</code>.</p><p>:::tip</p><p><a href="https://thegraph.com/docs/developer/create-subgraph-hosted#the-graphql-schema">Read more about the Graph schemas here.</a></p><p>:::</p><h3>Define Mappings</h3><p>Mappings are defined in <code>./src/mappings.ts</code> and transform the contract data (events) into the entities that are defined in <code>schema.graphql</code>. These mappings are written in a subset of Typescript. </p><p>In this example, there is only one event being indexed, so there is only one mapping.</p><pre><code class="language-ts">import { NameUpdated } from &#x27;../generated/HelloWorld/HelloWorld&#x27;
import { Name } from &#x27;../generated/schema&#x27;

export function handleNameUpdated(event: NameUpdated): void {
  let id = event.transaction.hash.toHex()
  let name = Name.load(id)
  if (name == null) {
    name = new Name(id)
  }
  name.newName = event.params.newName
  name.updater = event.params.updater
  name.save()
}
</code></pre><p>This mapping sets the entity <code>id</code> as the transaction hash, the entity <code>newName</code> as the newName from the event parameter and the entity <code>updater</code> as the updater from the event parameter. The mapping will update an entity if one with a known <code>id</code> already exists, but since transaction hashes are unique, each event emitted from the contract will create a new entity.</p><p>:::tip</p><p>You can find more information about mappings on <a href="https://thegraph.com/docs/developer/create-subgraph-hosted#writing-mappings">the Graph website here</a>.</p><p>:::</p><p>Once the mapping is defined, you can generate the Graph AssemblyScript by running</p><pre><code class="language-bash">graph codegen
</code></pre><p>&quot;This will generate an AssemblyScript class for every smart contract in the ABI files mentioned in subgraph.yaml, allowing you to bind these contracts to specific addresses in the mappings and call read-only contract methods against the block being processed. It will also generate a class for every contract event to provide easy access to event parameters as well as the block and transaction the event originated from.&quot;</p><p><em>--<a href="https://thegraph.com/docs/developer/create-subgraph-hosted#code-generation">The Graph codegen docs</a></em> </p><h3>Deploy Subgraph</h3><p>To deploy the subgraph to the hosted service, you will need to create an account on <a href="https://thegraph.com/hosted-service">the Graph&#x27;s hosted service site</a>.</p><p>From the <a href="https://thegraph.com/hosted-service/dashboard">dashboard</a>, you can find your Access Token for deploying the subgraph. Once you have that, you can authenticate with:</p><pre><code class="language-bash">graph auth --product hosted-service &lt;ACCESS_TOKEN&gt;
</code></pre><p>Next, click the &quot;Add Subgraph&quot; button. Fill out the subgraph info with the appropriate information and deploy it with:</p><pre><code class="language-bash">graph deploy --product hosted-service &lt;GITHUB_USER&gt;/&lt;SUBGRAPH NAME&gt;
</code></pre><p>Once your subgraph is deployed, you should be able to view it on the hosted service dashboard. You can view my <a href="https://thegraph.com/hosted-service/subgraph/critesjosh/hello-world">Hello World subgraph page here</a>.</p><p><img src="dashboard.png"/></p><p>Once the subgraph is deployed, the service will take some time to sync the events from the contract. Once it has been fully synced, you can run queries in the playground to test it out.</p><h3>Query the subgraph</h3><p>You can learn more about <a href="https://thegraph.com/docs/hostedservice/query-hosted-service">querying your subgraph from the hosted service here</a>.</p><p>The following embedded code notebook from <a href="https://observablehq.com/">Observable HQ</a> shows how to query the subgraph I deployed with basic Javascript. You can <a href="https://observablehq.com/@critesjosh/query-the-graph">view the notebook on Observable here</a>. I wrote a post that goes into more detail about Observable, you can <a href="../2021-11-18-observable-intro/index.md">read it here</a>.</p><p>You can inspect the JavaScript objects in the notebook by clicking on them. Try clicking on the <code>result</code> object. Click on the <code>names</code> array in the <code>data</code> object.</p><iframe width="100%" height="500" frameborder="0" class="observable-notebook" src="https://observablehq.com/embed/@critesjosh/query-the-graph?cell=*"></iframe><p>You can see the entities that were defined in the <code>schema.graphql</code>, populated with event information like the <code>newName</code> and <code>updater</code> from each transaction!</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Demos with ObservableHQ]]></title>
            <link>https://docs.lmax.pro/blog/observable-intro</link>
            <guid>observable-intro</guid>
            <pubDate>Thu, 18 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[Learn more about Observable notebooks and how they can be used in a blog]]></description>
            <content:encoded><![CDATA[<h2>What is Observable?</h2><p><a href="https://observablehq.com/">Observable HQ</a> is a Javascript notebook tool that makes it easy to share executable Javascript code right in the browser. This greatly reduces the friction around introducing and educating people about tools or features. Observable is designed primarily as a data visualization tool, but I have found it to be helpful for explaining and demonstrating concepts and behaviors for web3 as well.</p><p>For the official introduction to Observable, <a href="https://observablehq.com/@observablehq/five-minute-introduction?collection=@observablehq/introduction">check out the 5 minute introduction.</a></p><h2>Why I like it</h2><h3>Easy to setup</h3><p>First of all, there is nothing to download! This is a huge benefit when introducing developers to new technology. I can show off features and techniques for using new tech without requiring developers to have to download anything or set up an environment. This makes it easier to spark curiosity and inspire people to continue on their learning journey.</p><h3>Code + Visualizations + Text</h3><p>Observable supports Javascript, Markdown and HTML in cells. This means I can write executable Javascript surrounded by markdown that helps explain the context in which this code can be used and may be useful. The notebooks are also easy to embed into other contexts (like this blog).</p><p>Here is an example from a post on Merkle Trees. You can <a href="https://observablehq.com/@critesjosh/merkle-trees">view the full notebook here.</a></p><iframe width="100%" height="643" frameborder="0" class="observable-notebook" src="https://observablehq.com/embed/@critesjosh/merkle-trees?cells=chart%2Cp1%2Cvisualize_heading"></iframe><h3>Executable Javascript</h3><p>Observable allows anyone inspect the Javascript in the notebook and displays the results of the code execution. This is particularly useful to demo interactions with a connected web3 wallet or reviewing the structure of responses from API calls. Also, when code in one cell is updated, all other cells that use the code are referenced as well, kind of like hot reloading.</p><p>For example, in the <a href="../2021-11-18-using-the-graph/index.md">graph post</a>, I make a query to the Graph and the notebook shows a live response. Viewers can click through the notebook response to insepct the results.</p><p><a href="https://observablehq.com/@critesjosh/query-the-graph"><img src="query.gif" alt="the graph query"/></a></p><h3>Remix + Share</h3><p>Viewers can edit the Javascript in the notebook and execute their own code to see the results. They can fork their changes and save them in their own notebook to be worked on later or to share with others.</p><p>I can import common node packages into a notebook and run them as I would in an application. This allows me to quickly test things and share them.</p><h2>What I don&#x27;t like</h2><p>Using Observable isn&#x27;t great for everything--it has its limitations.</p><h3>Limited packages</h3><p>While many npm packages work with observable, not all of them do. You may need to build packages to work specifically for Observable or import minified versions from a CDN. <a href="https://observablehq.com/@observablehq/module-require-debugger">This tool</a> can help you figure out how to import packages that you want to use.</p><h3>Simple, specific actions</h3><p>Observable is great for showing simple interactions with packages or creating visualizations, but is not well suited for demonstrating how to design or build an application. It is a unique environment where Javascript syntax may be different than what developers are used to, so it is useful for specific things.</p><h3>Iframe limitations</h3><p>Observable notebooks are easiest to embed in other pages using an <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe">iframe</a>. This means the context of the notebook is limited by the same things as an iframe, which may or may not be a problem, depending on what you are trying to do. There are ways around this as well, you can link readers directly to your notebook or embed the notebook using a React component or vanilla Javascript. You can read more about embedding on the <a href="https://observablehq.com/@observablehq/introduction-to-embedding">Observable site here</a>.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Code Playground -- Metamask]]></title>
            <link>https://docs.lmax.pro/blog/code-metamask</link>
            <guid>code-metamask</guid>
            <pubDate>Tue, 16 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[Playing with Metamask]]></description>
            <content:encoded><![CDATA[<p>Let&#x27;s see how we can interact with Metamask from the code playground. We can connect to Metamask, switch networks, add tokens to the Metamask asset list and send them to other accounts.</p><p>This post uses a live code editor. Check out <a href="2021-11-15-code-playground.md">this post</a> to learn more about how it works.</p><p>:::tip</p><p>Make sure that you have have <a href="https://metamask.io">Metamask installed</a> in your browser.</p><p>:::</p><h2>Connect to Metamask</h2><p>The following example shows how to connect Metamask to this browser page.</p><p>:::note</p><p>This function will only trigger an action if Metamask is not yet connect to the site. If you&#x27;ve already connected, nothing will happen.</p><p>:::</p><pre><code class="language-jsx" metastring="live">function connect() {
  function connectMetamask() {
    ethereum.request({ method: &quot;eth_requestAccounts&quot; });
  }

  return &lt;button onClick={connectMetamask}&gt;Connect Metamask&lt;/button&gt;;
}
</code></pre><h3>Switch Networks</h3><p>This example shows how you can prompt a user to connect to a specific Celo network. This component renders two buttons, one to connect to Celo mainnet and one to connect to the Alfajores testnet. If you try to connect to a network that you are already connected to, nothing happens.</p><p>Try it out:</p><pre><code class="language-jsx" metastring="live">function MetamaskSwitchNetwork() {
  const NETWORK_PARAMS = {
    chainName: &quot;Celo&quot;,
    nativeCurrency: {
      name: &quot;Celo&quot;,
      symbol: &quot;CELO&quot;,
      decimals: 18,
    },
  };

  const MAINNET_PARAMS = {
    ...NETWORK_PARAMS,
    chainId: &quot;0xa4ec&quot;, // 42220
    rpcUrls: [&quot;https://forno.celo.org&quot;],
    blockExplorerUrls: [&quot;https://explorer.celo.org/&quot;],
  };

  const ALFAJORES_PARAMS = {
    ...NETWORK_PARAMS,
    chainId: &quot;0xaef3&quot;, // 44787
    rpcUrls: [&quot;https://alfajores-forno.celo-testnet.org&quot;],
    blockExplorerUrls: [&quot;https://alfajores-blockscout.celo-testnet.org/&quot;],
  };

  function addMainnet() {
    window.ethereum.request({
      method: &quot;wallet_addEthereumChain&quot;,
      params: [MAINNET_PARAMS],
    });
  }

  function addAlfajores() {
    window.ethereum.request({
      method: &quot;wallet_addEthereumChain&quot;,
      params: [ALFAJORES_PARAMS],
    });
  }

  return (
    &lt;div&gt;
      &lt;button onClick={addMainnet}&gt;Connect to Celo Mainnet&lt;/button&gt;
      &lt;br /&gt;
      &lt;button onClick={addAlfajores}&gt;Connect to Alfajores Testnet&lt;/button&gt;
      &lt;br /&gt;
    &lt;/div&gt;
  );
}
</code></pre><h3>Add Tokens</h3><p>The following code example shows how you can add the cUSD token on the Alfajores testnet to Metamask. To add other tokens, just update the parameter options. You can read more about the Metamask API <a href="https://docs.metamask.io/guide/rpc-api.html#wallet-watchasset">here</a>.</p><pre><code class="language-jsx" metastring="live">function MetamaskAddToken() {
  const TOKEN_PARAMS = {
    type: &quot;ERC20&quot;,
    options: {
      address: &quot;0x874069Fa1Eb16D44d622F2e0Ca25eeA172369bC1&quot;,
      symbol: &quot;cUSD&quot;,
      decimals: 18,
    },
  };

  function addToken() {
    window.ethereum.request({
      method: &quot;wallet_watchAsset&quot;,
      params: TOKEN_PARAMS,
    });
  }

  return &lt;button onClick={addToken}&gt;Add cUSD (Alfajores)&lt;/button&gt;;
}
</code></pre><h3>Send Tokens</h3><p>Let&#x27;s try to send some CELO on Alfajores. Make sure you are connected to the Alfajores testnet, you can double check by clicking the <code>Connect to Alfajores Testnet</code> button above again.</p><p>Make sure you have some Alfajores CELO to send. If you need some, you can get some from <a href="https://celo.org/developers/faucet">the faucet here</a>.</p><pre><code class="language-jsx" metastring="live">function MetamaskSendCelo() {
  const TX_PARAMS = {
    to: &quot;0x5038ae19CDf0B623e6e8015249ecF58A1165D653&quot;,
    from: ethereum.selectedAddress,
    value: &quot;0x11111111111111&quot;,
  };

  async function send() {
    let txID = await window.ethereum.request({
      method: &quot;eth_sendTransaction&quot;,
      params: [TX_PARAMS],
    });
    console.log(txID);
  }

  return &lt;button onClick={send}&gt;Send CELO (Alfajores)&lt;/button&gt;;
}
</code></pre><p>Click the button to send some CELO. Once you click submit, the transaction id will be logged in the browser console!</p><p>To send cUSD or interact with any other smart contract, you will have to encode the data and include it in the transaction data field. Libraries like <a href="https://web3js.readthedocs.io/en/v1.5.2/">web3.js</a> and <a href="https://www.npmjs.com/package/@celo/contractkit">contractkit</a> make this easier. We will go over using web3.js and contractkit in future posts.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Intro to the Code Playground]]></title>
            <link>https://docs.lmax.pro/blog/code-playground</link>
            <guid>code-playground</guid>
            <pubDate>Mon, 15 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[Playing with Code]]></description>
            <content:encoded><![CDATA[<p>This post provides an introduction to the live code editor that is included as a feature in this blog. It allows you to see working examples of things like connecting to the Celo network with Metamask and initiating user transactions with the SDK.</p><p>If you have any suggestions for examples that you&#x27;d like to see, or if you&#x27;d like to create one yourself and have it included in the blog, please reach out to me at <a href="mailto:josh@clabs.co">josh@clabs.co</a> or on Discord at joshc#0001.</p><h2>Live coding</h2><p>This is a live, editable code block. You can update the code right on this page and it will be compiled and executed as you updated it. This is a powerful feature for learning and testing code in real time--you get immediate feedback about what works and what doesn&#x27;t.</p><p>:::note</p><p>The code is rendered using <a href="https://github.com/FormidableLabs/react-live">React Live</a>. This means that the code is rendered as a React component, which gives you access to React features like hooks, but also limits what is possible.</p><p>:::</p><h3>Hello World</h3><p>Try it out:</p><pre><code class="language-jsx" metastring="live">function helloWorld(){

  return &lt;p&gt;Hello World!&lt;/p&gt;

}
</code></pre><p>Edit the code to return some new text. Try rendering different HTML.</p><p>You can see that the result is a simple rendering of the return statement, which is just HTML. The component must include a return statement, although you can return an empty string. You can also log stuff to your browser console from the environment.</p><h3>Logging</h3><p>See this example that returns an empty string and logs the browser <code>Window</code> object.</p><pre><code class="language-jsx" metastring="live">function logger(){
  console.log(window)
  return &quot;&quot;
}
</code></pre><p>Cool!</p><p>This is just a small preview into what code sharing and learning experiences we can build with this tool. Check out this post about <a href="2021-11-16-connect-to-metamask.md">Connecting to Metamask</a> to learn more.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Contributing to the Blog]]></title>
            <link>https://docs.lmax.pro/blog/blog-contributions</link>
            <guid>blog-contributions</guid>
            <pubDate>Mon, 08 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[How to contribute to the blog]]></description>
            <content:encoded><![CDATA[<p>Contribute to Celo.</p><h2>Open Source</h2><p>Celo is an open source project and without community contributions from people like you Celo wouldn&#x27;t exist. We welcome contributions to our <a href="https://github.com/celo-org">codebase</a>, <a href="https://github.com/celo-org/docs">documentation</a>, <a href="https://celo.crowdin.com/">translations</a> and <a href="https://github.com/celo-org/docs/blog">blog</a>.</p><p>It can be difficult to find ways to meaningfully contribute to a new project, but writing a guest post on our blog is a great way to get started!</p><p>Write about your experience as a member of the Celo community, whether you&#x27;re a CELO owner or a project founder. Your experience and perspective is valuable and can help others.</p><h2>Blog Ideas</h2><p>Here are some topics that you could write about:</p><ul><li>Document your experience onboarding to Celo</li><li>Share how Celo has impacted your life</li><li>Using DeFi on Celo</li><li>Minting tokens on Celo</li><li>How to build a product or service on Celo</li><li>How to debug transactions using the Truffle debugger</li><li>Getting events using the Graph protocol</li><li>How to contribute to specific Celo packages</li><li>Project spotlights (your own project or researching another)</li></ul><h2>How to Contribute</h2><h3>File naming</h3><p>Creating a new post in the blog is straightforward. Create a new file in the <a href="https://github.com/celo-org/docs/tree/main/blog">blog directory</a> in the documentation repository. Filenames follow the format of <code>YYYY-MM-DD-post-name.md</code>. For example, this post was written November 8th, 2021 so it has the filename <code>2021-11-08-contributing.md</code>.</p><h3>Front Matter</h3><p>Posts are written in <a href="https://www.markdownguide.org/">Markdown</a>. Posts include front matter. Front matter is file metadata at the top of the file that provides more information about the post. The front matter for this post looks like this:</p><pre><code class="language-md">---
title: Contributing to the Blog
description: How to contribute to the blog
slug: blog-contributions
authors:
  - name: Josh Crites
    title: Developer Relations, cLabs
    url: https://github.com/critesjosh
    image_url: https://github.com/critesjosh.png
tags: [contribute]
image: https://i.imgur.com/mErPwqL.png
hide_table_of_contents: false
---
</code></pre><h3>Post summary</h3><p>Pages can also include a <code>&lt;!--truncate--&gt;</code> tag that specifies what text will be shown along with the post title on the post list page. Any text above <code>&lt;!--truncate--&gt;</code> will appear as the post summary.</p><h3>Adding static assets</h3><p>If you would like to include images or other static assets in a post, you can create a folder following the naming convention described above (YYYY-MM-DD-post-name). The contents of the folder can include the images and the post (with filename index.md).</p><p>For examples of how other posts do this and to see how other features are implemented (like <a href="./2021-11-15-code-playground.md">live coding</a>), check out other posts source code in the <a href="https://github.com/celo-org/docs/tree/main/blog">blog directory on GitHub</a>.</p><h2>Reach out</h2><p>If you have any questions, feel free to join our Discord server at <a href="https://chat.celo.org">https://chat.celo.org</a> and feel free to reach out to me. My username is joshc#0001.</p>]]></content:encoded>
        </item>
    </channel>
</rss>