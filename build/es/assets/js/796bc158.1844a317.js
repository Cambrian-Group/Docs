"use strict";(self.webpackChunkcelo_docs=self.webpackChunkcelo_docs||[]).push([[8454],{3905:function(e,t,a){a.d(t,{Zo:function(){return p},kt:function(){return d}});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),u=c(a),d=i,m=u["".concat(l,".").concat(d)]||u[d]||h[d]||o;return a?n.createElement(m,s(s({ref:t},p),{},{components:a})):n.createElement(m,s({ref:t},p))}));function d(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=a.length,s=new Array(o);s[0]=u;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:i,s[1]=r;for(var c=2;c<o;c++)s[c]=a[c];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},5699:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return r},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return p},default:function(){return u}});var n=a(83117),i=a(80102),o=(a(67294),a(3905)),s=["components"],r={title:"Optics",description:"Introduction to Optics, it's core concepts, architecture, process, and implementation."},l="Optics",c={unversionedId:"celo-codebase/protocol/optics",id:"celo-codebase/protocol/optics",title:"Optics",description:"Introduction to Optics, it's core concepts, architecture, process, and implementation.",source:"@site/docs/celo-codebase/protocol/optics.md",sourceDirName:"celo-codebase/protocol",slug:"/celo-codebase/protocol/optics",permalink:"/es/celo-codebase/protocol/optics",editUrl:"https://celo.crowdin.com/celo-docs/es",tags:[],version:"current",frontMatter:{title:"Optics",description:"Introduction to Optics, it's core concepts, architecture, process, and implementation."},sidebar:"docs",previous:{title:"Celo Randomness",permalink:"/es/celo-codebase/protocol/identity/randomness"},next:{title:"Plumo Ultralight Sync",permalink:"/es/celo-codebase/protocol/plumo"}},p=[{value:"What is Optics?",id:"what-is-optics",children:[],level:2},{value:"Building Intuition for Optics",id:"building-intuition-for-optics",children:[],level:2},{value:"How does Optics work?",id:"how-does-optics-work",children:[],level:2},{value:"Optics Architecture",id:"optics-architecture",children:[],level:2},{value:"On-chain (Contracts)",id:"on-chain-contracts",children:[{value:"Home",id:"home",children:[],level:3},{value:"Replica",id:"replica",children:[],level:3},{value:"Updater",id:"updater",children:[],level:3},{value:"Watcher",id:"watcher",children:[],level:3},{value:"Relayer",id:"relayer",children:[],level:3},{value:"Processor",id:"processor",children:[],level:3}],level:2},{value:"How Optics passes messages between chains",id:"how-optics-passes-messages-between-chains",children:[],level:2},{value:"Optical Channels for Cross-Chain Communication",id:"optical-channels-for-cross-chain-communication",children:[],level:2},{value:"Benefits and Trade-offs of the Optics Architecture",id:"benefits-and-trade-offs-of-the-optics-architecture",children:[],level:2}],h={toc:p};function u(e){var t=e.components,a=(0,i.Z)(e,s);return(0,o.kt)("wrapper",(0,n.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"optics"},"Optics"),(0,o.kt)("p",null,"Introduction to Optics, it's core concepts, architecture, process, and implementation."),(0,o.kt)("hr",null),(0,o.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"Migrating to v2? Go ",(0,o.kt)("a",{parentName:"p",href:"https://docs.celo.org/celo-codebase/protocol/bridging/migrating-to-optics-v2"},"here")," to learn how to migrate from v1."))),(0,o.kt)("h2",{id:"what-is-optics"},"What is Optics?"),(0,o.kt)("p",null,"Optics is a new design for radically cheaper cross-chain communication without header verification. We expect operating Optics to cut 90% of gas costs compared to a traditional header relay. To accomplish this, we took inspiration from optimistic systems (a la Optimistic Roll-ups). Optics features many of the features we prize in an optimistic mechanism, like public verification, low gas fees, broad participation, but has a slightly different security model. "),(0,o.kt)("p",null,"Optics will form the base layer of a cross-chain communication network that provides fast, cheap communication for all smart contract chains and rollups. It relies only on widely-available cryptographic primitives (unlike header relays), has a latency of a few hours (rather than an ORU\u2019s one week latency), and imposes only about 120,000 gas overhead on message senders."),(0,o.kt)("p",null,"Optics has been designed for ease of implementation in any blockchain that supports user-defined computations. We will provide initial Solidity implementations of the on-chain contracts, and Rust implementations of the off-chain system agents. We aim to follow up with Rust implementations of the on-chain contracts targeting Near and Solana later this year."),(0,o.kt)("h2",{id:"building-intuition-for-optics"},"Building Intuition for Optics"),(0,o.kt)("p",null,"Optics works something like a notary service."),(0,o.kt)("img",{width:"1172",alt:"optics-notary",src:"https://user-images.githubusercontent.com/2653576/115466701-4a3c9880-a1e5-11eb-87e3-ae1cbab49b0b.png"}),(0,o.kt)("p",null,'The sending (or \u201chome\u201d) chain produces a series of documents ("messages") that needs notarization. A notary (called the \u201cupdater\u201d) is contracted to sign it. The notary can produce a fraudulent copy, but they will be punished by having their bond and license publicly revoked. When this happens, everyone relying on the notary learns that the notary is malicious. All the notary\'s customers can immediately block the notary and prevent any malicious access to their accounts.'),(0,o.kt)("h2",{id:"how-does-optics-work"},"How does Optics work?"),(0,o.kt)("p",null,"Optics is patterned after optimistic systems. It sees an attestation of some data, and accepts it as valid after a timer elapses. While the timer is running, honest participants have a chance to respond to the attestation and/or submit fraud proofs. "),(0,o.kt)("p",null,"Unlike most optimistic systems, Optics spans multiple chains. The sending chain is the source of truth, and contains the \u201cHome\u201d contract where messages are enqueued. Messages are committed to in a merkle tree (the \u201cmessage tree\u201d). The root of this tree is notarized by the updater and relayed to the receiving chain in an \u201cupdate\u201d. Updates are signed by the updater. They commit to the previous root and a new root. "),(0,o.kt)("p",null,"Any chain can maintain a \u201cReplica\u201d contract, which holds knowledge of the updater and the current root. Signed updates are held by the Replica, and accepted after a timeout. The Replica effectively replays a series of updates to reach the same root as the Home chain. Because the root commits to the message tree, once the root has been transmitted this way, the message can be proven and processed."),(0,o.kt)("p",null,"This leaves open the possibility that the Updater signs a fraudulent update. Unlike an optimistic rollup, Optics permits fraud. This is the single most important change to the security model. Importantly, fraud can always be proven to the Home contract on the sending chain. Because of this, the updater must submit a bonded stake on the sending chain. Fraud can always be proven on the sending chain, and the bond can be slashed as punishment. "),(0,o.kt)("p",null,"Unfortunately, certain types of fraud can't be objectively proven on the receiving chain; Replicas can't know which messages the home chain intended to send and therefore can't check message tree validity in all cases. However, if a message is falsified by an Updater and submitted to the Replica, that update is public. This means that any honest actor can prove this fraud on the original Home contract and cause slashing. There is no way to hide fraud. "),(0,o.kt)("p",null,"In addition, because the Replica waits to process messages, Optics guarantees that honest dapps can always prevent processing of dishonest messages. Fraud is always public knowledge before the fraudulent message is processed. In this sense, Optics (like atomic swaps and other locally verified systems) includes a requirement for honest users to stay online. We have built a robust system for delegating this responsibility."),(0,o.kt)("p",null,"All off-chain observers can be immediately convinced of fraud (as they can check the home chain). This means that the validity of a message sent by Optics is not 100% guaranteed. "),(0,o.kt)("p",null,"Instead, Optics guarantees the following:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Fraud is costly")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"All users can learn about fraud")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"All users can block a fraudulent message before they are accepted"),(0,o.kt)("p",{parentName:"li"},"  In other words, rather than using a globally verifiable fraud-proof, Optics relies on local verification by participants. This tradeoff allows Optics to save 90% on gas fees compared to pessimistic relays, while still maintaining a high degree of security."))),(0,o.kt)("h2",{id:"optics-architecture"},"Optics Architecture"),(0,o.kt)("p",null,"Optics contains several on-chain and off-chain components. For convenience, we\u2019ll be referring to the Home and Replica as contracts, when in fact they are several contracts working together."),(0,o.kt)("img",{width:"638",alt:"optics-on-chain-components",src:"https://user-images.githubusercontent.com/2653576/115467293-2463c380-a1e6-11eb-80be-348714044eb4.png"}),(0,o.kt)("h2",{id:"on-chain-contracts"},"On-chain (Contracts)"),(0,o.kt)("h3",{id:"home"},"Home"),(0,o.kt)("p",null,"The home contract is responsible for managing production of the message tree and holding custody of the updater bond. "),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"It performs the following functions:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},'Expose a "send message" API to other contracts on the home chain'),(0,o.kt)("li",{parentName:"ul"},"Enforce the message format"),(0,o.kt)("li",{parentName:"ul"},"Commit messages to the message tree"),(0,o.kt)("li",{parentName:"ul"},"Maintain a queue of tree roots"),(0,o.kt)("li",{parentName:"ul"},"Slash the updater's bond",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Double-update proofs"),(0,o.kt)("li",{parentName:"ul"},"Improper update proofs")))),(0,o.kt)("h3",{id:"replica"},"Replica"),(0,o.kt)("p",null,"The replica contract is responsible for managing optimistic replication and dispatching messages to end recipients. "),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"It performs the following functions:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Maintain a queue of pending updates"),(0,o.kt)("li",{parentName:"ul"},"Finalize updates as their timeouts elapse"),(0,o.kt)("li",{parentName:"ul"},"Accept double-update proofs"),(0,o.kt)("li",{parentName:"ul"},"Validate message inclusion proofs"),(0,o.kt)("li",{parentName:"ul"},"Enforce the message format"),(0,o.kt)("li",{parentName:"ul"},"Ensure messages are processed in order"),(0,o.kt)("li",{parentName:"ul"},"Dispatch messages to their destination"),(0,o.kt)("li",{parentName:"ul"},"Off-chain (Agents)")),(0,o.kt)("h3",{id:"updater"},"Updater"),(0,o.kt)("p",null,"The updater is responsible for signing attestations of new roots. "),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"It is an off-chain actor that does the following:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Observe the home chain contract"),(0,o.kt)("li",{parentName:"ul"},"Sign attestations to new roots"),(0,o.kt)("li",{parentName:"ul"},"Publish the signed attestation to the home chain")),(0,o.kt)("h3",{id:"watcher"},"Watcher"),(0,o.kt)("p",null,"The watcher observes the Updater's interactions with the Home contract (by watching the Home contract) and reacts to malicious or faulty attestations. It also observes any number of replicas to ensure the Updater does not bypass the Home and go straight to a replica. "),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"It is an off-chain actor that does the following:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Observe the home"),(0,o.kt)("li",{parentName:"ul"},"Observe 1 or more replicas"),(0,o.kt)("li",{parentName:"ul"},"Maintain a DB of seen updates"),(0,o.kt)("li",{parentName:"ul"},"Submit double-update proofs"),(0,o.kt)("li",{parentName:"ul"},"Submit invalid update proofs"),(0,o.kt)("li",{parentName:"ul"},"If configured, issue an emergency halt transaction")),(0,o.kt)("h3",{id:"relayer"},"Relayer"),(0,o.kt)("p",null,"The relayer forwards updates from the home to one or more replicas. "),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"It is an off-chain actor that does the following:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Observe the home"),(0,o.kt)("li",{parentName:"ul"},"Observe 1 or more replicas"),(0,o.kt)("li",{parentName:"ul"},"Polls home for new signed updates (since replica's current root) and submits them to replica"),(0,o.kt)("li",{parentName:"ul"},"Polls replica for confirmable updates (that have passed their optimistic time window) and confirms if available (updating replica's current root)")),(0,o.kt)("h3",{id:"processor"},"Processor"),(0,o.kt)("p",null,"The processor proves the validity of pending messages and sends them to end recipients. "),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"It is an off-chain actor that does the following:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Observe the home"),(0,o.kt)("li",{parentName:"ul"},"Maintain local merkle tree with all leaves"),(0,o.kt)("li",{parentName:"ul"},"Observe 1 or more replicas"),(0,o.kt)("li",{parentName:"ul"},"Maintain list of messages corresponding to each leaf"),(0,o.kt)("li",{parentName:"ul"},"Generate and submit merkle proofs for pending (unproven) messages"),(0,o.kt)("li",{parentName:"ul"},"Dispatch proven messages to end recipients")),(0,o.kt)("h2",{id:"how-optics-passes-messages-between-chains"},"How Optics passes messages between chains"),(0,o.kt)("img",{width:"951",alt:"optics-messages-between-chains",src:"https://user-images.githubusercontent.com/2653576/115468191-925cba80-a1e7-11eb-85a6-032539a7004f.png"}),(0,o.kt)("p",null,'Optics creates an authenticated data structure on a home chain, and relays updates to that data structure on any number of replicas. As a result, the home chain and all replicas will agree on the state of the data structure. By embedding data ("messages") in this data structure we can propagate it between chains with a high degree of confidence.'),(0,o.kt)("p",null,"The home chain enforces rules on the creation of this data structure. In the current design, this data structure is a sparse merkle tree based on the design used in the eth2 deposit contract. This tree commits to the vector of all previous messages. The home chain enforces an addressing and message scheme for messages and calculates the tree root. This root will be propagated to the replicas. The home chain maintains a queue of roots (one for each message)."),(0,o.kt)("p",null,'The home chain elects an "updater" that must attest to the state of the message tree. The updater places a bond on the home chain and is required to periodically sign attestations (updates or U). Each attestation contains the root from the previous attestation (U_prev), and a new root (U_new).'),(0,o.kt)("p",null,"The home chain slashes when it sees two conflicting updates (U_i and U_i' where U_i_prev == U_i'_prev && U_i_new != U_i'_new) or a single update where U_new is not an element of the queue. The new root MUST be a member of the queue. E.g a list of updates U_1...U_i should follow the form ","[(A, B), (B, C), (C, D)...]","."),(0,o.kt)("p",null,"Semantically, updates represent a batch commitment to the messages between the two roots. Updates contain one or more messages that ought to be propagated to the replica chain. Updates may occur at any frequency, as often as once per message. Because updates are chain-independent, any home chain update may be presented to any replica, and any replica update may be presented to the home chain. In other words, data availability of signed updates is guaranteed by each chain."),(0,o.kt)("p",null,"Before accepting an update, a replica places it into a queue of pending updates. Each update must wait for some time parameter before being accepted. While a replica can't know that an update is certainly valid, the waiting system guarantees that fraud is publicly visible on the home chain before being accepted by the replica. In other words, the security guarantee of the system is that all frauds may be published by any participant, all published frauds may be slashed, and all participants have a window to react to any fraud. Therefore updates that are not blacklisted by participants are sufficiently trustworthy for the replica to accept."),(0,o.kt)("h2",{id:"optical-channels-for-cross-chain-communication"},"Optical Channels for Cross-Chain Communication"),(0,o.kt)("p",null,"Optics sends messages from one chain to another in the form of raw bytes. A cross-chain application that wishes to use Optics will need to define the rules for sending and receiving messages for its use case."),(0,o.kt)("p",null,"Each cross-chain application must implement its own messaging protocol. By convention, we call the contracts that implement this protocol the application's Router contracts. Their function is broadly similar to routers in local networks. They ensure that incoming and outgoing messages are in the protocol-defined format, and facilitate handling and dispatch."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"These Router contracts must:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"maintain a permissioned set of the contract(s) on remote chains from which it will accept messages via Optics \u2014 this could be a single owner of the application on one chain; it could be a registry of other applications implementing the same rules on various chains")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"encode messages in a standardized format, so they can be decoded by the Router contract on the destination chain")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"handle messages from remote Router contracts")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"dispatch messages to remote Router contracts"),(0,o.kt)("p",{parentName:"li"},"  By implementing these pieces of functionality within a Router contract and deploying it across multiple chains, we create a working cross-chain application using a common language and set of rules. Applications of this kind may use Optics as the cross-chain courier for sending and receiving messages to each other."))),(0,o.kt)("h2",{id:"benefits-and-trade-offs-of-the-optics-architecture"},"Benefits and Trade-offs of the Optics Architecture"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"th"},"Benefits")),(0,o.kt)("th",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"th"},"Challenges")))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Broadcast channel"),(0,o.kt)("td",{parentName:"tr",align:null},"1-of-N fraud-proof trust model")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Cheap"),(0,o.kt)("td",{parentName:"tr",align:null},"Liveness failure if updater goes down")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"One-solution fits all"),(0,o.kt)("td",{parentName:"tr",align:null},"Updater could voluntarily forfeit bond to try to pass forged messages")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Simple"),(0,o.kt)("td",{parentName:"tr",align:null},"\xa0")))),(0,o.kt)("p",null,"The benefit of Optics is that the broadcast channel allows for a single-producer, multi-consumer model. This ensures that 1 accumulator can communicate with any number of receiving chains. It\u2019s also much cheaper than other options, allowing updates and proofs to cost <100k gas and be checked by only 1 signature. With Optics, one-solution fits all meaning that constraints on receiving chains are minimal (1 hash function + 1 signature check). There is no implementation or security difference between Proof of Stake and Proof of Work chains.  There is also many fewer LoC than a Relay, much lower design maintenance overhead, and much less expertise required to maintain and operate."),(0,o.kt)("p",null,"We\u2019ve been careful to address all concerns with the Optics system and have designed solutions that allow for optimal speed, cost, and security of the network. For example, we rely on fraud publication rather than fraud proofs to improve the speed and cost of sending messages. In this security model, any potential fraud is disincentivized and costly, and all participants will always learn of any potential fraud with plenty of time to mitigate harm."))}u.isMDXComponent=!0}}]);